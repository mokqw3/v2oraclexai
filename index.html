<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ORACLE X AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=El+Messiri:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>
    <style>
        /* Base styles for both login and app */
        body {
            font-family: 'Inter', sans-serif; /* Changed to Inter as per instructions */
            background: linear-gradient(135deg, #FFD1DC, #FFC0CB); /* Light Pink Background */
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            margin: 0;
            padding: 0;
            color: #1f2937;
            /* Added for main app layout flexbox */
            display: flex;
            flex-direction: column;
        }
        :root {
            /* Updated to Light Red and Pink Palette */
            --soft-black: #2C002B; /* Darker tone for text, still in palette */
            --light-black: #4A0048; /* Slightly lighter for secondary text */
            --light-gray: #E0BBE4; /* Soft greyish pink */
            --primary-pink: #FF69B4; /* Deep Pink */
            --secondary-pink: #FFC0CB; /* Light Pink */
            --accent-red: #FF416C; /* Bright Red-Pink for emphasis */
            --dark-violet: #8A2BE2; /* For 0 and 5, deeper */

            /* Redefining color usage for clarity and consistency */
            --success-color: #A3D9B1; /* Soft Green for wins, as a contrasting accent */
            --success-text: #1E8449;
            --danger-color: #FF7B8C; /* Softer Red for losses */
            --danger-text: #E74C3C;
            --warning-color: #FFD1DC; /* Light Pink for pending/warnings */
            --warning-text: #F39C12; /* Orange for warning text */
            --info-color: #B2D7F6; /* Light Blue for info */
            --info-text: #3498DB;
            --server-status-connected: #A3D9B1; /* Soft Green for server connected */


            /* Login specific colors, harmonized with app colors */
            --login-primary: var(--primary-pink);
            --login-primary-light: var(--secondary-pink);
            --login-primary-dark: var(--accent-red);
            --login-secondary: var(--primary-pink);
            --login-white: #FFFFFF;
            --login-light-bg: #FDF2F8;
            --login-text-dark: var(--soft-black);
            --login-text-light: var(--light-black);
        }
        * {
            color: var(--soft-black);
        }

        /* Login Screen Specific Styles */
        #loginScreen {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
            width: 100%; /* Ensure it takes full width */
            transition: opacity 0.5s ease;
        }
        .login-container {
            background: var(--login-white);
            backdrop-filter: blur(8px);
            border-radius: 16px;
            box-shadow: 0 10px 20px rgba(255, 105, 180, 0.2); /* Pink shadow */
            padding: 2rem;
            width: 100%;
            max-width: 400px;
            position: relative;
            z-index: 2;
            border: 1px solid var(--login-primary-light);
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
        }
        .login-container.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .login-container:hover {
            box-shadow: 0 12px 25px rgba(255, 105, 180, 0.3); /* Pinker shadow */
            transform: translateY(-3px);
        }
        .logo-container {
            text-align: center;
            margin-bottom: 1.5rem;
            transform: scale(0.9);
            opacity: 0;
        }
        .logo-img {
            width: 90px;
            height: 90px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid var(--login-primary);
            box-shadow: 0 8px 15px rgba(255, 105, 180, 0.25); /* Pink shadow */
            margin: 0 auto;
            transition: all 0.3s ease;
        }
        .logo-img:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 20px rgba(255, 105, 180, 0.4); /* Pink shadow */
        }
        .title {
            color: var(--login-primary-dark);
            font-weight: 700;
            font-size: 1.7rem;
            margin-top: 0.8rem;
            background: linear-gradient(to right, var(--login-primary), var(--login-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .last-key {
            color: var(--login-text-light);
            font-size: 0.9rem;
            margin-top: 0.5rem;
            font-weight: 500;
        }
        .error-message {
            color: var(--danger-text);
            text-align: center;
            margin-top: 0.8rem;
            font-weight: 500;
            font-size: 0.9rem;
            transform: scale(0.95);
            opacity: 0;
            padding: 8px;
            border-radius: 6px;
            background-color: rgba(255, 123, 140, 0.1);
            border-left: 3px solid var(--danger-text);
        }
        .success-message {
            color: var(--success-text);
            text-align: center;
            margin-top: 0.8rem;
            font-weight: 500;
            font-size: 0.9rem;
            transform: scale(0.95);
            opacity: 0;
            padding: 8px;
            border-radius: 6px;
            background-color: rgba(163, 217, 177, 0.1);
            border-left: 3px solid var(--success-text);
        }
        .input-group {
            position: relative;
            margin-bottom: 1.2rem;
            transform: translateX(-20px);
            opacity: 0;
        }
        .input-icon {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--login-primary-dark);
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        .input-field {
            width: 100%;
            padding: 12px 18px 12px 45px;
            border-radius: 10px;
            border: 1px solid var(--login-primary-light);
            background-color: var(--login-white);
            font-size: 0.95rem;
            color: var(--login-text-dark);
            transition: all 0.3s ease;
        }
        .input-field:focus {
            outline: none;
            border-color: var(--login-primary-dark);
            box-shadow: 0 0 0 3px rgba(255, 105, 180, 0.15); /* Pink shadow */
        }
        .input-field:focus + .input-icon {
            transform: translateY(-50%) scale(1.1);
            color: var(--login-secondary);
        }
        .submit-btn {
            width: 100%;
            padding: 14px;
            border-radius: 10px;
            background: linear-gradient(to right, var(--login-primary), var(--login-secondary));
            color: var(--login-white);
            font-weight: 600;
            font-size: 0.95rem;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
            transform: translateY(20px);
            opacity: 0;
            box-shadow: 0 5px 15px rgba(255, 105, 180, 0.2); /* Pink shadow */
            position: relative;
            overflow: hidden;
        }
        .submit-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: all 0.5s ease;
        }
        .submit-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(255, 105, 180, 0.3); /* Pink shadow */
        }
        .submit-btn:hover::before {
            left: 100%;
        }
        .copy-btn {
            width: 100%; /* Make copy button full width for consistency */
            padding: 10px 18px;
            border-radius: 8px;
            background: var(--login-primary-light);
            border: none;
            color: var(--login-primary-dark);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 0.8rem;
            transform: translateY(20px);
            opacity: 0;
            box-shadow: 0 3px 10px rgba(255, 105, 180, 0.1); /* Pink shadow */
            position: relative;
            overflow: hidden;
        }
        .copy-btn:hover {
            background: var(--login-primary-dark);
            color: var(--login-white);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 105, 180, 0.2); /* Pink shadow */
        }
        .copy-animation {
            position: absolute;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.2);
            left: -100%;
            top: 0;
            transition: all 0.3s ease;
        }
        .copy-btn.copied .copy-animation {
            left: 0;
        }
        .loading-message {
            color: var(--login-primary-dark);
            text-align: center;
            margin-top: 0.8rem;
            font-weight: 500;
            display: none;
        }
        .social-links {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 1.5rem;
            opacity: 0;
            transform: translateY(20px);
        }
        .social-link {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--login-white);
            font-size: 1.1rem;
            transition: all 0.3s ease;
            background: linear-gradient(to bottom right, var(--login-primary), var(--login-secondary));
            box-shadow: 0 3px 10px rgba(255, 105, 180, 0.2); /* Pink shadow */
        }
        .social-link:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(255, 105, 180, 0.3); /* Pink shadow */
        }
        .floating-element {
            position: absolute;
            background-color: var(--login-primary-light);
            border-radius: 50%;
            z-index: 1;
            filter: blur(1px);
            opacity: 0.5;
        }
        .star {
            position: absolute;
            background-color: var(--login-white);
            border-radius: 50%;
            z-index: 1;
            animation: twinkle var(--duration) infinite ease-in-out;
            opacity: 0;
        }
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(0.9); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-15px) rotate(3deg); }
        }
        .confetti {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: var(--login-primary-dark);
            opacity: 0;
            z-index: 10;
        }
        @media (max-width: 480px) {
            .login-container { padding: 1.5rem; }
            .logo-img { width: 70px; height: 70px; }
            .title { font-size: 1.4rem; }
            .last-key, .error-message, .success-message { font-size: 0.8rem; }
            .input-field { padding: 10px 15px 10px 40px; font-size: 0.9rem; }
            .submit-btn, .copy-btn { padding: 12px; font-size: 0.9rem; }
        }

        /* Main App Specific Styles (inherited and overridden) */
        #mainAppScreen {
            flex-grow: 1; /* Allow main app content to take available space */
            display: none; /* Hidden by default, shown after login */
            width: 100%;
            /* min-height: 100vh; */ /* Managed by body flex-col */
            /* Removed flex-direction: column; as body now handles it */
        }

        /* --- From oracle-x-ai-app.html --- */
        .popup, .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            border: 2px solid var(--light-gray);
        }
        .popup.active, .modal.active { display: block; }
        .win-popup, .loss-popup, .pattern-warning, .history-deleted-popup, .unstable-trend-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            border: 2px solid var(--success-color); /* Win popup border */
            text-align: center;
        }
        .loss-popup, .pattern-warning { border: 2px solid var(--danger-color); }
        .history-deleted-popup { border: 2px solid var(--primary-pink); }
        .unstable-trend-popup { border: 2px solid var(--warning-color); } /* New popup border */

        .win-popup.active, .loss-popup.active, .pattern-warning.active, .history-deleted-popup.active, .unstable-trend-popup.active { display: block; }
        .confetti-icon { font-size: 2rem; margin-bottom: 1rem; }
        .play-resume {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem;
            border-radius: 1.5rem;
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            border: 2px solid var(--success-color);
            text-align: center;
        }
        .play-resume.active { display: block; }
        .play-icon { font-size: 2rem; margin-bottom: 1rem; color: var(--success-text); }
        .card {
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 1.5rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            position: relative;
            margin: 0.75rem;
            overflow: hidden;
        }
        .card:hover {
            transform: translateY(-6px) scale(1.03);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
        }
        .gradient-bg { background: linear-gradient(135deg, var(--primary-pink), var(--accent-red)); } /* Pink/Red Gradient */
        svg {
            width: 100%;
            height: auto;
            margin: 0 auto;
            display: block;
        }
        svg text {
            text-anchor: middle;
            dominant-baseline: middle;
            text-transform: uppercase;
            animation: stroke 5s infinite alternate;
            stroke-width: 1.2;
            stroke: var(--primary-pink); /* Updated stroke color */
            font-size: 10vw; /* Adjusted for responsiveness */
            fill: rgba(255, 255, 255, 0);
        }
        @media (min-width: 768px) {
            svg text { font-size: 130px; } /* Larger font for desktop */
        }
        @keyframes stroke {
            0% { fill: rgba(255, 255, 255, 0); stroke: var(--primary-pink); stroke-dashoffset: 25%; stroke-dasharray: 0 50%; stroke-width: 1.2; }
            70% { fill: rgba(255, 255, 255, 0); stroke: var(--accent-red); } /* Updated stroke color */
            80% { fill: rgba(255, 255, 255, 0); stroke: var(--secondary-pink); stroke-width: 2.5; } /* Updated stroke color */
            100% { fill: var(--light-gray); stroke: rgba(0, 0, 0, 0); stroke-dashoffset: -25%; stroke-dasharray: 50% 0; stroke-width: 0; }
        }
        .history-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-height: none;
            overflow: visible;
            position: relative;
        }
        .history-item {
            transition: all 0.3s ease;
            width: 100%;
            max-width: 100%;
            margin: 0;
            border-radius: 1.2rem;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(8px);
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            padding: 1.2rem;
            border-left: 4px solid transparent; 
        }
        .history-item.win { border-left-color: var(--success-color); background: linear-gradient(135deg, rgba(163, 217, 177, 0.08), rgba(255, 255, 255, 0.9)); }
        .history-item.loss { border-left-color: var(--danger-color); background: linear-gradient(135deg, rgba(255, 123, 140, 0.08), rgba(255, 255, 255, 0.9)); }
        .history-item.pending { border-left-color: var(--warning-color); background: linear-gradient(135deg, rgba(255, 209, 220, 0.08), rgba(255, 255, 255, 0.9)); }
        .history-item.skipped { border-left-color: var(--light-gray); background: linear-gradient(135deg, rgba(224, 187, 228, 0.08), rgba(255, 255, 255, 0.9)); }
        .history-item:hover { transform: scale(1.02); box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15); }
        .history-item.fade-out { animation: fadeOut 0.5s ease forwards; }
        @keyframes fadeOut {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.95); height: 0; padding: 0; margin: 0; }
        }
        .history-item .watermark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-45deg);
            font-size: 1.5rem;
            color: rgba(0, 0, 0, 0.05);
            pointer-events: none;
            z-index: 0;
            text-transform: uppercase;
            font-weight: bold;
        }
        .small-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: var(--primary-pink); /* Updated dot color */
            border-radius: 50%;
            animation: float 4s infinite;
            z-index: 1;
        }
        @keyframes float {
            0% { transform: translate(0, 0); opacity: 0.9; }
            50% { transform: translate(12px, -12px); opacity: 0.5; }
            100% { transform: translate(0, 0); opacity: 0.9; }
        }
        .delete-btn:hover { color: var(--accent-red); transform: scale(1.3); } /* Updated delete btn hover */
        .win-badge { background: rgba(163, 217, 177, 0.15); color: var(--success-text); }
        .loss-badge { background: rgba(255, 123, 140, 0.15); color: var(--danger-text); }
        .pending-badge { background: rgba(255, 209, 220, 0.15); color: var(--warning-text); }
        .skipped-badge { background: rgba(224, 187, 228, 0.15); color: var(--light-black); }
        .status-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            position: relative;
            overflow: hidden;
        }
        .status-icon::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            opacity: 0.2;
            background: radial-gradient(circle, currentColor 0%, transparent 70%);
        }
        .win-icon { color: var(--success-text); animation: pulseWin 1.5s infinite; }
        .loss-icon { color: var(--danger-text); animation: pulseLoss 1s infinite; }
        .pending-icon { color: var(--warning-text); animation: rotate 2s infinite linear; }
        .skipped-icon { color: var(--light-black); animation: pulseSkip 1.5s infinite; }
        @keyframes pulseWin {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(163, 217, 177, 0.4); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(163, 217, 177, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(163, 217, 177, 0); }
        }
        @keyframes pulseLoss {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        @keyframes pulseSkip {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .dashboard-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 1.5rem;
            padding: 1.2rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
        }
        .dashboard-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.15);
        }
        .confidence-meter {
            height: 10px;
            background: var(--light-gray);
            border-radius: 5px;
            overflow: hidden;
            position: relative;
            margin-top: 0.5rem; /* Make visible by default */
            display: block; /* Make visible by default */
        }
        .confidence-fill {
            height: 100%;
            background: var(--success-color); /* Default to success color */
            transition: width 0.5s ease;
        }
        .confidence-fill.red { background: var(--danger-color); }
        .confidence-fill.violet { background: var(--dark-violet); }
        /* Prediction badges for Size/Color */
        .big-badge { background: rgba(163, 217, 177, 0.15); color: var(--success-text); } /* Big (Success) */
        .small-badge { background: rgba(255, 123, 140, 0.15); color: var(--danger-text); } /* Small (Danger) */
        .green-badge { background: rgba(163, 217, 177, 0.15); color: var(--success-text); } /* Green (Success) */
        .red-badge { background: rgba(255, 123, 140, 0.15); color: var(--danger-text); } /* Red (Danger) */
        .violet-badge { background: rgba(138, 43, 226, 0.15); color: var(--dark-violet); } /* Violet (Dark Violet) */


        /* Confidence Level Badges */
        .level-badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 9999px; /* Tailwind's rounded-full */
            font-size: 0.75rem; /* text-xs */
            font-weight: 600; /* font-semibold */
            margin-left: 0.5rem;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .level-1-badge { background-color: var(--warning-color); color: var(--warning-text); } /* Light Pink/Orange */
        .level-2-badge { background-color: var(--info-color); color: var(--info-text); } /* Light Blue */
        .level-3-badge { background-color: var(--success-color); color: var(--success-text); } /* Light Green */


        .navigation {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 350px;
            height: 70px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 1.5rem;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }
        .navigation ul { display: flex; width: 300px; }
        .navigation ul li {
            position: relative;
            list-style: none;
            width: 75px;
            height: 70px;
            z-index: 1;
        }
        .navigation ul li a {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            width: 100%;
            text-align: center;
            font-weight: 500;
        }
        .navigation ul li a .icon {
            position: relative;
            display: block;
            line-height: 75px;
            font-size: 1.5em;
            text-align: center;
            transition: 0.5s;
            color: var(--soft-black);
        }
        .navigation ul li.active a .icon { transform: translateY(-32px); color: var(--primary-pink); } /* Updated nav icon color */
        .navigation ul li a .text {
            position: absolute;
            font-weight: 400;
            font-size: 0.75em;
            letter-spacing: 0.05em;
            transition: 0.5s;
            opacity: 0;
            transform: translateY(20px);
            color: var(--soft-black);
        }
        .navigation ul li.active a .text { opacity: 1; transform: translateY(10px); }
        .indicator {
            position: absolute;
            top: -50%;
            width: 70px;
            height: 70px;
            background: var(--primary-pink); /* Updated indicator color */
            border-radius: 50%;
            border: 6px solid var(--secondary-pink); /* Updated border color */
            transition: 0.5s;
        }
        .indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: -22px;
            width: 20px;
            height: 20px;
            background: transparent;
            border-top-right-radius: 20px;
            box-shadow: 1px -10px 0 0 var(--secondary-pink); /* Updated shadow color */
        }
        .indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            right: -22px;
            width: 20px;
            height: 20px;
            background: transparent;
            border-top-left-radius: 20px;
            box-shadow: -1px -10px 0 0 var(--secondary-pink); /* Updated shadow color */
        }
        .navigation ul li:nth-child(1).active ~ .indicator { transform: translateX(calc(75px * 0)); }
        .navigation ul li:nth-child(2).active ~ .indicator { transform: translateX(calc(75px * 1)); }
        .navigation ul li:nth-child(3).active ~ .indicator { transform: translateX(calc(75px * 2)); }
        .navigation ul li:nth-child(4).active ~ .indicator { transform: translateX(calc(75px * 3)); }
        .content-section { display: none; }
        .content-section.active { display: block; }
        .stats-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem; }
        .mode-toggle {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        .mode-toggle input { opacity: 0; width: 0; height: 0; }
        .mode-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--light-gray);
            transition: .4s;
            border-radius: 34px;
        }
        .mode-slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: #ffffff;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .mode-slider { background-color: var(--primary-pink); } /* Toggle active color */
        input:checked + .mode-slider:before { transform: translateX(30px); }
        .mode-icons {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 8px;
            pointer-events: none;
        }
        .mode-icons i, .mode-icons span {
            font-size: 14px;
            color: var(--soft-black);
        }
        .contact-links {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }
        .contact-link {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-decoration: none;
            font-size: 12px;
            color: var(--soft-black);
        }
        .contact-link i {
            font-size: 20px;
            margin-bottom: 5px;
            color: var(--primary-pink); /* Updated contact link icon color */
        }
        .period-id {
            font-family: monospace;
            letter-spacing: 2px;
            font-size: 1.2rem;
        }
        #currentPeriod, #currentResult { border: none !important; }
        .video-container {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            /* display: none; */ /* Keep display controlled by JS for popup */
        }
        .video-container iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        button, .btn {
            border-radius: 1rem;
            background: var(--primary-pink); /* Updated button background */
            backdrop-filter: blur(8px);
            transition: all 0.3s ease;
            color: #ffffff;
        }
        button:hover, .btn:hover {
            background: var(--accent-red); /* Updated button hover */
            transform: scale(1.05);
        }
        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            z-index: 2000;
            color: var(--soft-black);
        }

        /* Advanced Status Bar Styles */
        .advanced-status-bar {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(5px);
            padding: 0.75rem 1rem;
            border-radius: 1rem;
            margin-top: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            font-size: 0.85rem;
            color: var(--soft-black);
            display: none; /* Hidden by default, shown when advanced mode is on */
            flex-wrap: wrap;
            gap: 0.5rem;
            justify-content: center;
        }
        .advanced-status-bar.active { display: flex; }
        .advanced-status-bar span {
            background-color: var(--light-gray);
            padding: 0.25rem 0.6rem;
            border-radius: 0.5rem;
            font-weight: 500;
        }
        .advanced-status-bar span.good { background-color: rgba(163, 217, 177, 0.2); color: var(--success-text); }
        .advanced-status-bar span.warning { background-color: rgba(255, 209, 220, 0.2); color: var(--warning-text); }
        .advanced-status-bar span.danger { background-color: rgba(255, 123, 140, 0.2); color: var(--danger-text); }
        .advanced-status-bar span.info { background-color: rgba(178, 215, 246, 0.2); color: var(--info-text); }

        /* Responsive Adjustments */
        @media (max-width: 768px) {
            .card { padding: 0.75rem; margin: 0.5rem; border-radius: 1rem; }
            .grid-cols-2 { grid-template-columns: 1fr; }
            .md\\:grid-cols-3 { grid-template-columns: 1fr 1fr; }
            .text-3xl { font-size: 1.5rem; }
            .text-2xl { font-size: 1.25rem; }
            .text-xl { font-size: 1rem; }
            .text-lg { font-size: 0.875rem; }
            .text-sm { font-size: 0.75rem; }
            .p-6 { padding: 0.75rem; }
            .p-5 { padding: 0.5rem; }
            .w-12 { width: 2.5rem; height: 2.5rem; }
            .history-item { padding: 1rem; border-radius: 1rem; }
            .history-item .watermark { font-size: 1rem; }
            .rounded-xl { border-radius: 0.75rem; }
            .gap-4 { gap: 0.75rem; }
            .mb-4 { margin-bottom: 0.75rem; }
            .mb-2 { margin-bottom: 0.5rem; }
            .mb-1 { margin-bottom: 0.3rem; }
            .px-4 { padding-left: 0.75rem; padding-right: 0.75rem; }
            .px-2 { padding-left: 0.5rem; padding-right: 0.5rem; }
            .py-1 { padding-top: 0.25rem; padding-bottom: 0.25rem; }
            .space-x-2 > * + * { margin-left: 0.5rem; }
            .space-x-1 > * + * { margin-left: 0.3rem; }
            .navigation { width: 300px; border-radius: 1rem; }
            .navigation ul { width: 250px; }
            .navigation ul li { width: 62.5px; }
            .indicator { width: 60px; height: 60px; }
            .navigation ul li:nth-child(1).active ~ .indicator { transform: translateX(calc(62.5px * 0)); }
            .navigation ul li:nth-child(2).active ~ .indicator { transform: translateX(calc(62.5px * 1)); }
            .navigation ul li:nth-child(3).active ~ .indicator { transform: translateX(calc(62.5px * 2)); }
            .navigation ul li:nth-child(4).active ~ .indicator { transform: translateX(calc(62.5px * 3)); }
            .popup, .modal, .win-popup, .loss-popup, .play-resume, .history-deleted-popup, .unstable-trend-popup { max-width: 320px; padding: 1rem; border-radius: 1rem; }
            .advanced-status-bar {
                font-size: 0.7rem; /* Smaller font for mobile */
                padding: 0.5rem 0.75rem;
            }
            .advanced-status-bar span {
                margin-right: 0.5rem;
                padding: 0.15rem 0.3rem;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <!-- Login Screen -->
    <div id="loginScreen" class="min-h-screen w-full flex items-center justify-center">
        <div class="floating-element" style="width: 150px; height: 150px; top: 15%; left: 10%; background: radial-gradient(circle, var(--login-primary-light), transparent 70%);"></div>
        <div class="floating-element" style="width: 100px; height: 100px; bottom: 20%; right: 12%; background: radial-gradient(circle, var(--login-primary-light), transparent 70%);"></div>
        <div class="floating-element" style="width: 80px; height: 80px; top: 35%; right: 18%; background: radial-gradient(circle, var(--login-primary-light), transparent 70%);"></div>
        <div class="floating-element" style="width: 120px; height: 120px; bottom: 30%; left: 15%; background: radial-gradient(circle, var(--login-primary-light), transparent 70%);"></div>

        <div id="stars-container-login"></div>
        <div id="confetti-container-login"></div>

        <div class="login-container" id="loginContainer">
            <div class="logo-container">
                <img src="https://placehold.co/90x90/FF69B4/FFFFFF?text=AI" alt="ORACLE X AI Logo" class="logo-img">
                <h1 class="title">ORACLE X AI</h1>
                <div class="last-key" id="lastKey"></div>
                <div class="error-message" id="error"></div>
                <div class="success-message" id="success"></div>
            </div>

            <div class="input-group" id="inputGroup">
                <i class="fas fa-key input-icon"></i>
                <input type="text" id="accessKey" placeholder="Enter License Key" required class="input-field">
            </div>

            <div class="loading-message" id="loading">Loading...</div>

            <button class="submit-btn" id="submitBtn" onclick="handleLogin()">
                <i class="fas fa-sign-in-alt mr-2"></i> Login
            </button>

            <div class="text-center mt-4">
                <button class="copy-btn" id="copyDeviceIdButton" onclick="copyDeviceId()">
                    <span class="copy-animation"></span>
                    <i class="fas fa-copy mr-2"></i> 
                    <span id="copyText">Copy Device ID</span>
                </button>
            </div>

            <div class="text-center mt-4">
                <button class="copy-btn" onclick="getKey()">
                    <i class="fas fa-key mr-2"></i> Get Access Key
                </button>
            </div>

            <div class="social-links" id="socialLinks">
                <a href="https://t.me/ORACLEXAIADMIN" target="_blank" class="social-link" title="Telegram">
                    <i class="fab fa-telegram"></i>
                </a>
            </div>
        </div>
    </div>

    <!-- Main Predictor Application Screen -->
    <div id="mainAppScreen" class="w-full relative pb-20" style="display: none;">
        <header class="text-center mt-0 mb-2 animate__animated animate__fadeInDown">
            <svg viewBox="0 0 800 120">
                <text x="50%" y="50%">ORACLE X AI</text>
            </svg>
            <div id="advancedStatusBar" class="advanced-status-bar animate__animated animate__fadeIn">
                <!-- Content will be dynamically updated by JavaScript -->
            </div>
        </header>

        <div class="max-w-full mx-auto p-2 w-full">
            <div class="max-w-4xl mx-auto p-2 w-full">
                <!-- Home Section -->
                <div id="homeSection" class="content-section active">
                    <div class="card mb-4 overflow-hidden gradient-bg animate__animated animate__zoomIn relative">
                        <div class="bg-white bg-opacity-95 p-6 rounded-lg pulse-animation">
                            <div class="grid grid-cols-2 gap-4">
                                <div class="relative">
                                    <div class="pl-2">
                                        <div class="flex items-center space-x-2 mb-2">
                                            <i class="fas fa-calendar-alt text-2xl animate__animated animate__bounce"></i>
                                            <h2 class="text-2xl font-bold" data-lang-key="period">Period</h2>
                                        </div>
                                        <p id="currentPeriod" class="text-2xl font-semibold bg-white p-3 rounded-lg shadow-inner period-id">-</p>
                                    </div>
                                </div>
                                <div class="relative text-right">
                                    <div class="pr-2">
                                        <div class="flex items-center justify-end space-x-2 mb-2">
                                            <h2 id="predictionTitle" class="text-2xl font-bold" data-lang-key="prediction">Prediction</h2>
                                            <p id="currentPredictionResult" class="text-2xl font-semibold bg-white p-3 rounded-lg shadow-inner flex items-center justify-end">
                                                <span>-</span>
                                                <span id="predictionLevelDisplay" class="level-badge"></span>
                                            </p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="confidence-meter">
                                <div id="confidenceFill" class="confidence-fill" style="width: 0%"></div>
                            </div>
                            <p id="confidenceText" class="text-sm mt-1" data-lang-key="confidence_text">Confidence: 0%</p>
                        </div>
                        <div class="small-dot" style="top: 15%; left: 15%; animation-delay: 0.2s;"></div>
                        <div class="small-dot" style="top: 85%; left: 85%; animation-delay: 0.8s;"></div>
                        <div class="small-dot" style="top: 50%; left: 25%; animation-delay: 1.2s;"></div>
                        <div class="small-dot" style="top: 20%; left: 80%; animation-delay: 1.6s;"></div>
                    </div>

                    <div class="card mb-4 p-6 animate__animated animate__fadeInUp relative">
                        <h2 class="text-3xl font-bold text-center mb-4 relative">
                            <span class="relative z-10 pulse-animation" data-lang-key="analysis_dashboard">Analysis Dashboard</span>
                            <span class="absolute top-1/2 left-0 w-full h-2 bg-secondary-pink -translate-y-1/2 rounded-full"></span>
                        </h2>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-4">
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-star text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="most_frequent">Most Frequent</p>
                                        <p id="mostFrequent" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.1s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-arrow-down text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="least_frequent">Least Frequent</p>
                                        <p id="leastFrequent" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.2s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-percentage text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="win_rate">Win Rate</p>
                                        <p id="homeWinRate" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.3s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-trophy text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="wins">Wins</p>
                                        <p id="totalWinBets" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card animate__animated animate__fadeIn" style="animation-delay: 0.4s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-skull text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="losses">Losses</p>
                                        <p id="totalLossBets" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card flex items-center justify-between animate__animated animate__fadeIn" style="animation-delay: 0.5s;">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-server text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="server_status">Server Status</p>
                                        <p id="serverStatus" class="font-semibold" data-lang-key="connected">Connected</p>
                                    </div>
                                </div>
                                <div id="serverStatusIndicator" class="w-3 h-3 bg-server-status-connected rounded-full animate-ping"></div>
                            </div>
                        </div>
                        <div class="small-dot" style="top: 10%; left: 10%; animation-delay: 0.3s;"></div>
                        <div class="small-dot" style="top: 90%; left: 90%; animation-delay: 0.9s;"></div>
                        <div class="small-dot" style="top: 30%; left: 70%; animation-delay: 1.5s;"></div>
                    </div>
                </div>

                <!-- History Section -->
                <div id="historySection" class="content-section">
                    <div class="card p-6 animate__animated animate__fadeInUp relative">
                        <div class="flex justify-between items-center mb-4">
                            <h2 class="text-3xl font-bold text-center relative">
                                <span class="relative z-10 pulse-animation" data-lang-key="history">History</span>
                                <span class="absolute top-1/2 left-0 w-full h-2 bg-secondary-pink -translate-y-1/2 rounded-full"></span>
                            </h2>
                            <button id="deleteAllHistoryBtn" class="px-4 py-2 rounded-lg hover:bg-secondary-pink transition flex items-center">
                                <i class="fas fa-trash-alt mr-2"></i><span data-lang-key="delete">Delete</span>
                            </button>
                        </div>
                        <div id="history" class="history-container"></div>
                        <div class="small-dot" style="top: 20%; left: 30%; animation-delay: 0.4s;"></div>
                        <div class="small-dot" style="top: 80%; left: 70%; animation-delay: 0.9s;"></div>
                        <div class="small-dot" style="top: 40%; left: 50%; animation-delay: 1.3s;"></div>
                    </div>
                </div>

                <!-- Stats Section -->
                <div id="statsSection" class="content-section">
                    <div class="card p-6 animate__animated animate__fadeInUp relative">
                        <h2 class="text-3xl font-bold text-center mb-4 relative">
                            <span class="relative z-10 pulse-animation" data-lang-key="statistics">Statistics</span>
                            <span class="absolute top-1/2 left-0 w-full h-2 bg-secondary-pink -translate-y-1/2 rounded-full"></span>
                        </h2>
                        <div class="stats-grid">
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-trophy text-success-text text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="total_wins">Total Wins</p>
                                        <p id="statsTotalWins" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-skull text-danger-text text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="total_losses">Total Losses</p>
                                        <p id="statsTotalLosses" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-percentage text-warning-text text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="win_rate">Win Rate</p>
                                        <p id="statsWinRate" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-fire text-primary-pink text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="current_streak">Current Streak</p>
                                        <p id="currentStreak" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center space-x-2">
                                    <i class="fas fa-history text-info-text text-lg"></i>
                                    <div>
                                        <p class="text-sm" data-lang-key="last_five_results">Last 5 Results</p>
                                        <p id="lastFiveResults" class="text-xl font-bold">-</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="small-dot" style="top: 15%; left: 20%; animation-delay: 0.5s;"></div>
                        <div class="small-dot" style="top: 85%; left: 80%; animation-delay: 1s;"></div>
                    </div>
                </div>

                <!-- Settings Section -->
                <div id="settingsSection" class="content-section">
                    <div class="card p-6 animate__animated animate__fadeInUp relative">
                        <h2 class="text-3xl font-bold text-center mb-4 relative">
                            <span class="relative z-10 pulse-animation" data-lang-key="settings">Settings</span>
                            <span class="absolute top-1/2 left-0 w-full h-2 bg-secondary-pink -translate-y-1/2 rounded-full"></span>
                        </h2>
                        <div class="flex flex-col gap-4">
                            <!-- Status Card -->
                            <div class="dashboard-card">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fas fa-chart-line text-lg"></i>
                                        <div>
                                            <p class="text-sm" data-lang-key="status">Status</p>
                                            <p id="settingsTotalWins" class="text-sm" data-lang-key="total_wins_display">Total Wins: 0</p>
                                            <p id="settingsTotalLosses" class="text-sm" data-lang-key="total_losses_display">Total Losses: 0</p>
                                        </div>
                                    </div>
                                    <p id="eligibilityStatus" class="text-sm font-semibold text-warning-text" data-lang-key="pending">Pending</p>
                                </div>
                            </div>

                            <!-- Language Toggle (New) -->
                            <div class="dashboard-card">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fas fa-globe text-lg"></i>
                                        <p class="text-sm" data-lang-key="language">Language</p>
                                    </div>
                                    <label class="mode-toggle">
                                        <input type="checkbox" id="languageToggle">
                                        <span class="mode-slider"></span>
                                        <div class="mode-icons">
                                            <span class="text-sm">EN</span>
                                            <span class="text-sm">HI</span>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <!-- Notification Toggle -->
                            <div class="dashboard-card">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fas fa-bell text-lg"></i>
                                        <p class="text-sm" data-lang-key="notifications">Notifications</p>
                                    </div>
                                    <label class="mode-toggle">
                                        <input type="checkbox" id="notificationToggle">
                                        <span class="mode-slider"></span>
                                        <div class="mode-icons">
                                            <i class="fas fa-bell-slash"></i>
                                            <i class="fas fa-bell"></i>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fas fa-volume-up text-lg"></i>
                                        <p class="text-sm" data-lang-key="sound">Sound</p>
                                    </div>
                                    <label class="mode-toggle">
                                        <input type="checkbox" id="soundToggle" checked>
                                        <span class="mode-slider"></span>
                                        <div class="mode-icons">
                                            <i class="fas fa-volume-mute"></i>
                                            <i class="fas fa-volume-up"></i>
                                        </div>
                                    </label>
                                </div>
                            </div>
                            <div class="dashboard-card cursor-pointer hover:bg-secondary-pink transition" onclick="resetSettings()">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fas fa-undo text-lg"></i>
                                        <p class="text-sm" data-lang-key="reset_settings">Reset Settings</p>
                                    </div>
                                    <span class="text-sm" data-lang-key="reset">Reset</span>
                                </div>
                            </div>
                            <div class="dashboard-card">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fas fa-cog text-lg"></i>
                                        <p class="text-sm" data-lang-key="prediction_mode">Prediction Mode</p>
                                    </div>
                                    <label class="mode-toggle">
                                        <input type="checkbox" id="predictionModeToggle">
                                        <span class="mode-slider"></span>
                                        <div class="mode-icons">
                                            <i class="fas fa-moon"></i>
                                            <i class="fas fa-bolt"></i>
                                        </div>
                                    </label>
                                </div>
                            </div>

                            <!-- YouTube Video Card (New) -->
                            <div onclick="openVideoPopup()" class="dashboard-card cursor-pointer hover:bg-secondary-pink transition">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fab fa-youtube text-lg"></i>
                                        <p class="text-sm" data-lang-key="how_to_use">How To Use</p>
                                    </div>
                                    <span class="text-sm" data-lang-key="watch_video">Watch Video</span>
                                </div>
                            </div>

                            <!-- Telegram Card (New) -->
                            <div onclick="window.open('https://t.me/ORACLEXAIADMIN', '_blank')" class="dashboard-card cursor-pointer hover:bg-secondary-pink transition">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fab fa-telegram text-lg"></i>
                                        <p class="text-sm" data-lang-key="telegram">Telegram</p>
                                    </div>
                                    <span class="text-sm" data-lang-key="join_channel">Join Channel</span>
                                </div>
                            </div>

                            <!-- Instagram Card (New) -->
                            <div onclick="window.open('https://instagram.com/oracle.x.ai', '_blank')" class="dashboard-card cursor-pointer hover:bg-secondary-pink transition">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fab fa-instagram text-lg"></i>
                                        <p class="text-sm" data-lang-key="instagram">Instagram</p>
                                    </div>
                                    <span class="text-sm" data-lang-key="follow_us">Follow Us</span>
                                </div>
                            </div>

                            <!-- Privacy Policy Card (New) -->
                            <div onclick="window.open('https://alwaystruexyz.blogspot.com/2025/04/alpha-mx-pricing-plans-custom-css.html', '_blank')" class="dashboard-card cursor-pointer hover:bg-secondary-pink transition">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <i class="fas fa-shield-alt text-lg"></i>
                                        <p class="text-sm" data-lang-key="privacy_policy">Privacy Policy</p>
                                    </div>
                                    <span class="text-sm" data-lang-key="read_more">Read More</span>
                                </div>
                            </div>

                            <div class="contact-links">
                                <a href="https://t.me/ORACLEXAIADMIN" target="_blank" class="contact-link">
                                    <i class="fab fa-telegram"></i>
                                    <span data-lang-key="telegram">Telegram</span>
                                </a>
                                <a href="https://instagram.com/oracle.x.ai" target="_blank" class="contact-link">
                                    <i class="fab fa-instagram"></i>
                                    <span data-lang-key="instagram">Instagram</span>
                                </a>
                            </div>
                        </div>
                        <div class="small-dot" style="top: 10%; left: 15%; animation-delay: 0.6s;"></div>
                        <div class="small-dot" style="top: 90%; left: 85%; animation-delay: 1.1s;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Navigation -->
        <div class="navigation">
            <ul>
                <li class="active">
                    <a href="#" data-section="homeSection">
                        <span class="icon"><ion-icon name="home-outline"></ion-icon></span>
                        <span class="text" data-lang-key="home">Home</span>
                    </a>
                </li>
                <li>
                    <a href="#" data-section="historySection">
                        <span class="icon"><ion-icon name="time-outline"></ion-icon></span>
                        <span class="text" data-lang-key="history">History</span>
                    </a>
                </li>
                <li>
                    <a href="#" data-section="statsSection">
                        <span class="icon"><ion-icon name="bar-chart-outline"></ion-icon></span>
                        <span class="text" data-lang-key="stats">Stats</span>
                    </a>
                </li>
                <li>
                    <a href="#" data-section="settingsSection">
                        <span class="icon"><ion-icon name="settings-outline"></ion-icon></span>
                        <span class="text" data-lang-key="settings">Settings</span>
                    </a>
                </li>
                <div class="indicator"></div>
            </ul>
        </div>

        <!-- Video Popup (still exists but no button to open it) -->
        <div id="videoPopup" class="popup">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-lg font-semibold" data-lang-key="how_to_use_oracle_x_ai">How To Use ORACLE X AI</h3>
                <button onclick="closeVideoPopup()" class="hover:text-primary-pink">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div class="video-container">
                <iframe src="https://www.youtube.com/embed/dQw4w9WgXcQ" frameborder="0" allowfullscreen></iframe>
            </div>
        </div>

        <!-- Win Popup -->
        <div id="winPopup" class="win-popup">
            <div class="confetti-icon"></div>
            <h3 class="text-lg font-semibold mb-4" data-lang-key="congratulations">CONGRATULATIONS!</h3>
            <p class="mb-4" data-lang-key="win_message">You won this prediction!</p>
            <p id="winDetails" class="mb-4"></p>
        </div>

        <!-- Loss Popup -->
        <div id="lossPopup" class="loss-popup">
            <div class="confetti-icon"></div>
            <h3 class="text-lg font-semibold mb-4" data-lang-key="loss_message_title">LOSS!</h3>
            <p class="mb-4" data-lang-key="loss_message">Unfortunately, you lost this prediction.</p>
            <p id="lossDetails" class="mb-4"></p>
        </div>

        <!-- Pattern Warning Popup -->
        <div id="patternWarningPopup" class="pattern-warning">
            <div class="confetti-icon"></div>
            <h3 class="text-lg font-semibold mb-4" data-lang-key="pattern_warning_title">PATTERN WARNING!</h3>
            <p class="mb-4" data-lang-key="pattern_warning_message">5 consecutive losses detected. Pattern not good. Please wait 15 minutes before playing again.</p>
            <button onclick="pausePredictions()" class="bg-danger-color text-white px-4 py-2 rounded-lg hover:bg-danger-text transition" data-lang-key="close">CLOSE</button>
        </div>

        <!-- History Deleted Popup -->
        <div id="historyDeletedPopup" class="history-deleted-popup">
            <div class="confetti-icon"></div>
            <h3 class="text-lg font-semibold mb-4" data-lang-key="history_deleted_title">HISTORY DELETED!</h3>
            <p class="mb-4" data-lang-key="history_deleted_message">History has been successfully deleted.</p>
            <p id="historyDeleteDetails" class="mb-4"></p>
        </div>

        <!-- Unstable Trend Pause Popup (NEW) -->
        <div id="unstableTrendPopup" class="unstable-trend-popup">
            <div class="confetti-icon"></div>
            <h3 class="text-lg font-semibold mb-4" data-lang-key="unstable_trend_title">PREDICTION PAUSED: UNSTABLE TREND!</h3>
            <p class="mb-4" data-lang-key="unstable_trend_message">Market trend is currently unstable. Predictions will resume automatically.</p>
            <p class="text-2xl font-bold text-primary-pink mb-4" id="unstableTrendCountdown">20:00</p>
            <button onclick="resumePlaying()" class="bg-primary-pink text-white px-4 py-2 rounded-lg hover:bg-accent-red transition" data-lang-key="resume_now">Resume Now</button>
        </div>

        <!-- Play Resume Modal -->
        <div id="playResumeModal" class="play-resume">
            <div class="play-icon"><i class="fas fa-play"></i></div>
            <h3 class="text-lg font-semibold mb-4" data-lang-key="resume_playing_title">Resume Playing</h3>
            <p class="mb-4" data-lang-key="resume_playing_message">You can now resume predictions.</p>
            <button onclick="resumePlaying()" class="bg-success-color text-white px-4 py-2 rounded-lg hover:bg-success-text transition" data-lang-key="resume">Resume</button>
        </div>

        <!-- Confirmation Modal -->
        <div id="confirmModal" class="modal">
            <h3 class="text-lg font-semibold mb-4" data-lang-key="confirm_action">Confirm Action</h3>
            <p id="modalMessage" class="mb-4"></p>
            <div class="flex justify-end space-x-2">
                <button id="cancelModalBtn" class="bg-gray-300 text-gray-700 px-4 py-2 rounded-lg hover:bg-gray-400 transition" data-lang-key="cancel">Cancel</button>
                <button id="confirmModalBtn" class="bg-primary-pink text-white px-4 py-2 rounded-lg hover:bg-accent-red transition" data-lang-key="confirm">Confirm</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Import Firebase modules for Realtime Database and Authentication
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.0.0/firebase-app.js';
        import { getDatabase, ref, get, child, set, update, remove, onValue } from 'https://www.gstatic.com/firebasejs/9.0.0/firebase-database.js';
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.0.0/firebase-auth.js'; // Import onAuthStateChanged

        // Firebase Config (Canvas will inject this)
        const firebaseConfig = {
            apiKey: "AIzaSyBS8SJNrWcrnNhxzgSnMhmLWslSnxJ3vXM",
            authDomain: "newq-7386b.firebaseapp.com",
            projectId: "newq-7386b",
            storageBucket: "newq-7386b.firebase-storage.app",
            messagingSenderId: "939070208594",
            appId: "1:939070208594:web:b7b952fb7ca541ab32fd8b",
            databaseURL: "https://newq-7386b-default-rtdb.firebaseio.com/"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const auth = getAuth(app);
        
        // References to Firebase database nodes
        const accessKeysRef = ref(db, 'accessKeys'); 
        let userHistoryRef; // Will be set after user authentication
        let userSettingsRef; // Will be set after user authentication

        let currentUserUid = null; // Stores the Firebase Authentication UID
        let isAuthReady = false; // Flag to indicate if initial Firebase auth check is complete

        // Dynamically get app ID from Canvas environment or default
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

        // --- Firebase Authentication for Main App ---
        async function initiateAuthentication() {
            try {
                if (typeof __initial_auth_token !== 'undefined') {
                    try {
                        await signInWithCustomToken(auth, __initial_auth_token);
                        console.log("Firebase custom token authentication successful.");
                    } catch (customTokenError) {
                        console.warn("Custom token sign-in failed, attempting anonymous sign-in:", customTokenError);
                        // Fallback to anonymous sign-in if custom token fails
                        await signInAnonymously(auth);
                        console.log("Firebase anonymous authentication successful after custom token failure.");
                    }
                } else {
                    await signInAnonymously(auth);
                    console.log("Firebase anonymous authentication initiated (no custom token).");
                }
                // The 'onAuthStateChanged' listener will handle the screen transition and data loading.
            } catch (error) {
                console.error("Firebase Authentication initiation failed (general error):", error);
                showToast("Authentication failed. Please refresh and try again.");
                document.getElementById('mainAppScreen').style.display = 'none';
                document.getElementById('loginScreen').style.display = 'flex';
            }
        }

        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUserUid = user.uid;
                userHistoryRef = ref(db, `users/${currentUserUid}/predictionHistory`);
                userSettingsRef = ref(db, `users/${currentUserUid}/userSettings`);
                console.log("Firebase authentication successful. User UID:", currentUserUid);
                await loadUserDataFromFirebase(); 
            } else {
                console.log("User is signed out or authentication failed.");
                currentUserUid = null;
                document.getElementById('mainAppScreen').style.display = 'none';
                document.getElementById('loginScreen').style.display = 'flex';
                if (predictionInterval) {
                    clearInterval(predictionInterval);
                    predictionInterval = null;
                }
            }
            isAuthReady = true; 
        });

        document.addEventListener('DOMContentLoaded', initiateAuthentication);

        // --- Translation Object (from website_1746246515.html) ---
        const translations = {
            en: {
                period: "Period",
                prediction: "Prediction",
                confidence_text: "Confidence:",
                analysis_dashboard: "Analysis Dashboard",
                most_frequent: "Most Frequent",
                least_frequent: "Least Frequent",
                win_rate: "Win Rate",
                wins: "Wins",
                losses: "Losses",
                server_status: "Server Status",
                connected: "Connected",
                disconnected: "Disconnected",
                history: "History",
                delete: "Delete",
                statistics: "Statistics",
                total_wins: "Total Wins",
                total_losses: "Total Losses",
                current_streak: "Current Streak",
                last_five_results: "Last 5 Results",
                settings: "Settings",
                status: "Status",
                total_wins_display: "Total Wins:",
                total_losses_display: "Total Losses:",
                language: "Language",
                notifications: "Notifications",
                sound: "Sound",
                reset_settings: "Reset Settings",
                reset: "Reset",
                prediction_mode: "Prediction Mode",
                how_to_use: "How To Use",
                watch_video: "Watch Video",
                telegram: "Telegram",
                join_channel: "Join Channel",
                instagram: "Instagram",
                follow_us: "Follow Us",
                privacy_policy: "Privacy Policy",
                read_more: "Read More",
                home: "Home",
                stats: "Stats",
                how_to_use_oracle_x_ai: "How To Use ORACLE X AI",
                congratulations: "CONGRATULATIONS!",
                win_message: "You won this prediction!",
                loss_message_title: "LOSS!",
                loss_message: "Unfortunately, you lost this prediction.",
                pattern_warning_title: "PATTERN WARNING!",
                pattern_warning_message: "5 consecutive losses detected. Pattern not good. Please wait 15 minutes before playing again.",
                history_deleted_title: "HISTORY DELETED!",
                history_deleted_message: "History has been successfully deleted.",
                unstable_trend_title: "PREDICTION PAUSED: UNSTABLE TREND!",
                unstable_trend_message: "Market trend is currently unstable. Predictions will resume automatically.",
                resume_now: "Resume Now",
                resume_playing_title: "Resume Playing",
                resume_playing_message: "You can now resume predictions.",
                resume: "Resume",
                confirm_action: "Confirm Action",
                cancel: "Cancel",
                confirm: "Confirm",
                pending: "Pending",
                delete_item_confirm: "Are you sure you want to delete this history item?",
                delete_all_confirm: "Are you sure you want to delete all history items?",
                reset_settings_confirm: "Are you sure you want to reset all settings to default?"
            },
            hi: {
                period: "",
                prediction: "",
                confidence_text: ":",
                analysis_dashboard: " ",
                most_frequent: "  ",
                least_frequent: "  ",
                win_rate: "  ",
                wins: "",
                losses: "",
                server_status: " ",
                connected: " ",
                disconnected: "  ",
                history: "",
                delete: "",
                statistics: "",
                total_wins: " ",
                total_losses: " ",
                current_streak: " ",
                last_five_results: " 5 ",
                settings: "",
                status: "",
                total_wins_display: " :",
                total_losses_display: " :",
                language: "",
                notifications: "",
                sound: "",
                reset_settings: "  ",
                reset: "",
                prediction_mode: " ",
                how_to_use: "  ",
                watch_video: " ",
                telegram: "",
                join_channel: "   ",
                instagram: "",
                follow_us: "  ",
                privacy_policy: " ",
                read_more: " ",
                home: "",
                stats: "",
                how_to_use_oracle_x_ai: "      ",
                congratulations: " !",
                win_message: "   !",
                loss_message_title: "!",
                loss_message: " ,    ",
                pattern_warning_title: " !",
                pattern_warning_message: " 5          15        ",
                history_deleted_title: "   !",
                history_deleted_message: "     ",
                unstable_trend_title: "  :  !",
                unstable_trend_message: "              ",
                resume_now: "    ",
                resume_playing_title: "    ",
                resume_playing_message: "        ",
                resume: "   ",
                confirm_action: "   ",
                cancel: " ",
                confirm: " ",
                pending: "",
                delete_item_confirm: "        ?",
                delete_all_confirm: "        ?",
                reset_settings_confirm: "          ?"
            }
        };

        // --- Global variables for application state ---
        let historyData = []; 
        let lastFetchedPeriod = null; 
        let currentPredictionType = 'size'; 
        let predictionSwitchCounter = 0; 
        const PREDICTION_SWITCH_THRESHOLD = 3; 

        let streak = 0; 
        let winLevel = 0; 
        let lossStreak = 0; 
        let consecutiveLosses = 0; 
        let isPaused = false; 
        let isPatternGood = true; 
        const MAX_WIN_LEVEL = 3; 
        let currentSharedStats = { consecutiveSkips: 0 }; // Initialize shared stats

        // New for Unstable Trend Pause
        let unstableTrendTimerInterval = null;
        let unstableTrendTimeRemaining = 0;
        const UNSTABLE_TREND_PAUSE_DURATION_SECONDS = 20 * 60; // 20 minutes

        // User settings (now synchronized with Firebase)
        let currentLanguage = 'en'; // Default language
        let isSoundEnabled = true; 
        let isNotificationsEnabled = false;
        let isAdvancedMode = false;

        // Apply saved user settings after Firebase loads
        function applySettingsToUI() {
            document.getElementById('languageToggle').checked = (currentLanguage === 'hi');
            document.getElementById('notificationToggle').checked = isNotificationsEnabled;
            document.getElementById('soundToggle').checked = isSoundEnabled;
            document.getElementById('predictionModeToggle').checked = isAdvancedMode;
            updateAdvancedStatusBarVisibility(); // Update visibility based on loaded setting
            updateLanguage(); // Apply initial language
        }
        
        // --- PREDICTION LOGIC START ---
        // Helper Functions (from predictionLogic.js)
        function getBigSmallFromNumber(number) {
            if (number === undefined || number === null) return null;
            const num = parseInt(number);
            if (isNaN(num)) return null;
            return num >= 0 && num <= 4 ? 'SMALL' : num >= 5 && num <= 9 ? 'BIG' : null;
        }

        function getOppositeOutcome(prediction) {
            return prediction === "BIG" ? "SMALL" : prediction === "SMALL" ? "BIG" : null;
        }

        function calculateSMA(data, period) {
            if (!Array.isArray(data) || data.length < period || period <= 0) return null;
            const relevantData = data.slice(0, period);
            const sum = relevantData.reduce((a, b) => a + b, 0);
            return sum / period;
        }

        function calculateEMA(data, period) {
            if (!Array.isArray(data) || data.length < period || period <= 0) return null;
            const k = 2 / (period + 1);
            const chronologicalData = data.slice().reverse();

            const initialSliceForSma = chronologicalData.slice(0, period);
            if (initialSliceForSma.length < period) return null;

            let ema = calculateSMA(initialSliceForSma.slice().reverse(), period);
            if (ema === null && initialSliceForSma.length > 0) {
                ema = initialSliceForSma.reduce((a, b) => a + b, 0) / initialSliceForSma.length;
            }
            if (ema === null) return null;

            for (let i = period; i < chronologicalData.length; i++) {
                ema = (chronologicalData[i] * k) + (ema * (1 - k));
            }
            return ema;
        }

        function calculateStdDev(data, period) {
            if (!Array.isArray(data) || data.length < period || period <= 0) return null;
            const relevantData = data.slice(0, period);
            if (relevantData.length < 2) return null;
            const mean = relevantData.reduce((a, b) => a + b, 0) / relevantData.length;
            const variance = relevantData.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / (relevantData.length -1); 
            return Math.sqrt(variance);
        }

        function calculateRSI(data, period) {
            if (period <= 0) return null;
            const chronologicalData = data.slice().reverse();
            if (!Array.isArray(chronologicalData) || chronologicalData.length < period + 1) return null;
            let gains = 0, losses = 0;

            for (let i = 1; i <= period; i++) {
                const change = chronologicalData[i] - chronologicalData[i - 1];
                if (change > 0) gains += change;
                else losses += Math.abs(change);
            }

            let avgGain = gains / period;
            let avgLoss = losses / period;

            for (let i = period + 1; i < chronologicalData.length; i++) {
                const change = chronologicalData[i] - chronologicalData[i - 1];
                let currentGain = change > 0 ? change : 0;
                let currentLoss = change < 0 ? Math.abs(change) : 0;
                avgGain = (avgGain * (period - 1) + currentGain) / period;
                avgLoss = (avgLoss * (period - 1) + currentLoss) / period;
            }

            if (avgLoss === 0) return 100;
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function getCurrentISTHour() {
            try {
                const now = new Date();
                const istFormatter = new Intl.DateTimeFormat('en-US', {
                    timeZone: 'Asia/Kolkata',
                    hour: 'numeric',
                    hour12: false
                });
                const istHourString = istFormatter.formatToParts(now).find(part => part.type === 'hour').value;
                let hour = parseInt(istHourString, 10);
                if (hour === 24) hour = 0;

                return {
                    raw: hour,
                    sin: Math.sin(hour / 24 * 2 * Math.PI),
                    cos: Math.cos(hour / 24 * 2 * Math.PI)
                };
            } catch (error) {
                console.error("Error getting IST hour:", error);
                const hour = new Date().getHours();
                return {
                    raw: hour,
                    sin: Math.sin(hour / 24 * 2 * Math.PI),
                    cos: Math.cos(hour / 24 * 2 * Math.PI)
                };
            }
        }

        function getRealTimeExternalData() {
            let combinedFactor = 1.0;
            let reasons = [];

            const weatherConditions = ["Clear", "Clouds", "Haze", "Smoke", "Rain", "Drizzle"];
            const randomWeather = weatherConditions[Math.floor(Math.random() * weatherConditions.length)];
            let weatherFactor = 1.0;
            if (["Clear", "Clouds"].includes(randomWeather)) weatherFactor = 1.005;
            else if (["Rain", "Drizzle"].includes(randomWeather)) weatherFactor = 0.995;
            reasons.push(`W:${randomWeather}`);
            combinedFactor *= weatherFactor;

            const newsSentiments = ["Positive", "Neutral", "Negative"];
            const randomNewsSentiment = newsSentiments[Math.floor(Math.random() * newsSentiments.length)];
            let newsFactor = 1.0;
            if(randomNewsSentiment === "Positive") newsFactor = 1.01;
            else if(randomNewsSentiment === "Negative") newsFactor = 0.99;
            reasons.push(`N:${randomNewsSentiment}`);
            combinedFactor *= newsFactor;

            const eventRiskLevels = ["None", "Low", "Medium", "High"];
            const randomEventRisk = Math.random() < 0.9 ? eventRiskLevels[0] : eventRiskLevels[Math.floor(Math.random() * 3) + 1];
            let eventFactor = 1.0;
            if(randomEventRisk === "Medium") eventFactor = 0.97;
            else if(randomEventRisk === "High") eventFactor = 0.90;
            reasons.push(`Eco:${randomEventRisk}`);
            combinedFactor *= eventFactor;

            const socialTrends = ["None", "Bullish", "Bearish", "Mixed"];
            const randomSocialTrend = Math.random() < 0.8 ? socialTrends[0] : socialTrends[Math.floor(Math.random() * 3) + 1];
            let socialFactor = 1.0;
            if(randomSocialTrend === "Bullish") socialFactor = 1.015;
            else if(randomSocialTrend === "Bearish") socialFactor = 0.985;
            reasons.push(`Soc:${randomSocialTrend}`);
            combinedFactor *= socialFactor;

            const geoRiskLevels = ["Stable", "Tense", "Conflict"];
            const randomGeoRisk = Math.random() < 0.95 ? geoRiskLevels[0] : (Math.random() < 0.8 ? geoRiskLevels[1] : geoRiskLevels[2]);
            let geoFactor = 1.0;
            if (randomGeoRisk === "Tense") geoFactor = 0.95; 
            else if (randomGeoRisk === "Conflict") geoFactor = 0.80; 
            reasons.push(`Geo:${randomGeoRisk}`);
            combinedFactor *= geoFactor;

            return { factor: combinedFactor, reason: `ExtData(${reasons.join(',')})` };
        }

        function getPrimeTimeSession(istHour) {
            if (istHour >= 10 && istHour < 12) return { session: "PRIME_MORNING", aggression: 1.2, confidence: 1.1 };
            if (istHour >= 13 && istHour < 14) return { session: "PRIME_AFTERNOON_1", aggression: 1.1, confidence: 1.05 };
            if (istHour >= 15 && istHour < 16) return { session: "PRIME_AFTERNOON_2", aggression: 1.1, confidence: 1.05 };
            if (istHour >= 17 && istHour < 20) {
                if (istHour === 19) return { session: "PRIME_EVENING_PEAK", aggression: 1.3, confidence: 1.2 };
                return { session: "PRIME_EVENING", aggression: 1.25, confidence: 1.15 };
            }
            return null;
        }

        function getMarketRegimeAndTrendContext(history, shortMALookback = 5, mediumMALookback = 10, longMALookback = 20) {
            const baseContext = getTrendContext(history, shortMALookback, mediumMALookback, longMALookback);
            let macroRegime = "UNCERTAIN";
            const { strength, volatility } = baseContext;
            let isTransitioning = false;

            const numbers = history.map(entry => parseInt(entry.actualNumber || entry.actual)).filter(n => !isNaN(n));

            if (numbers.length > mediumMALookback + 5) {
                const prevShortMA = calculateEMA(numbers.slice(1), shortMALookback);
                const prevMediumMA = calculateEMA(numbers.slice(1), mediumMALookback);
                const currentShortMA = calculateEMA(numbers, shortMALookback);
                const currentMediumMA = calculateEMA(numbers, mediumMALookback);

                if (prevShortMA && prevMediumMA && currentShortMA && currentMediumMA) {
                    if ((prevShortMA <= prevMediumMA && currentShortMA > currentMediumMA) ||
                        (prevShortMA >= prevMediumMA && currentShortMA < currentMediumMA)) {
                        isTransitioning = true;
                    }
                }
            }

            if (strength === "STRONG") {
                if (volatility === "LOW" || volatility === "VERY_LOW") macroRegime = "TREND_STRONG_LOW_VOL";
                else if (volatility === "MEDIUM") macroRegime = "TREND_STRONG_MED_VOL";
                else macroRegime = "TREND_STRONG_HIGH_VOL";
            } else if (strength === "MODERATE") {
                if (volatility === "LOW" || volatility === "VERY_LOW") macroRegime = "TREND_MOD_LOW_VOL";
                else if (volatility === "MEDIUM") macroRegime = "TREND_MOD_MED_VOL";
                else macroRegime = "TREND_MOD_HIGH_VOL";
            } else if (strength === "RANGING") {
                if (volatility === "LOW" || volatility === "VERY_LOW") macroRegime = "RANGE_LOW_VOL";
                else if (volatility === "MEDIUM") macroRegime = "RANGE_MED_VOL";
                else macroRegime = "RANGE_HIGH_VOL";
            } else { 
                if (volatility === "HIGH") macroRegime = "WEAK_HIGH_VOL";
                else if (volatility === "MEDIUM") macroRegime = "WEAK_MED_VOL";
                else macroRegime = "WEAK_LOW_VOL";
            }

            if (isTransitioning && !macroRegime.includes("TRANSITION")) {
                macroRegime += "_TRANSITION";
            }

            baseContext.macroRegime = macroRegime;
            baseContext.isTransitioning = isTransitioning;
            baseContext.details += `,Regime:${macroRegime}`;
            return baseContext;
        }

        function getTrendContext(history, shortMALookback = 5, mediumMALookback = 10, longMALookback = 20) {
            if (!Array.isArray(history) || history.length < longMALookback) {
                return { strength: "UNKNOWN", direction: "NONE", volatility: "UNKNOWN", details: "Insufficient history", macroRegime: "UNKNOWN_REGIME", isTransitioning: false };
            }
            const numbers = history.map(entry => parseInt(entry.actualNumber || entry.actual)).filter(n => !isNaN(n));
            if (numbers.length < longMALookback) {
                return { strength: "UNKNOWN", direction: "NONE", volatility: "UNKNOWN", details: "Insufficient numbers", macroRegime: "UNKNOWN_REGIME", isTransitioning: false };
            }

            const shortMA = calculateEMA(numbers, shortMALookback);
            const mediumMA = calculateEMA(numbers, mediumMALookback);
            const longMA = calculateEMA(numbers, longMALookback);

            if (shortMA === null || mediumMA === null || longMA === null) return { strength: "UNKNOWN", direction: "NONE", volatility: "UNKNOWN", details: "MA calculation failed", macroRegime: "UNKNOWN_REGIME", isTransitioning: false };

            let direction = "NONE";
            let strength = "WEAK";
            let details = `S:${shortMA.toFixed(1)},M:${mediumMA.toFixed(1)},L:${longMA.toFixed(1)}`;

            const stdDevLong = calculateStdDev(numbers, longMALookback);
            const epsilon = 0.001;
            const normalizedSpread = (stdDevLong !== null && stdDevLong > epsilon) ? (shortMA - longMA) / stdDevLong : (shortMA - longMA) / epsilon;

            details += `,NormSpread:${normalizedSpread.toFixed(2)}`;

            if (shortMA > mediumMA && mediumMA > longMA) {
                direction = "BIG";
                if (normalizedSpread > 0.75) strength = "STRONG";
                else if (normalizedSpread > 0.40) strength = "MODERATE";
                else strength = "WEAK";
            } else if (shortMA < mediumMA && mediumMA < longMA) {
                direction = "SMALL";
                if (normalizedSpread < -0.75) strength = "STRONG";
                else if (normalizedSpread < -0.40) strength = "MODERATE";
                else strength = "WEAK";
            } else {
                strength = "RANGING";
                if (shortMA > longMA) direction = "BIG_BIASED_RANGE";
                else if (longMA > shortMA) direction = "SMALL_BIASED_RANGE";
            }

            let volatility = "UNKNOWN";
            const volSlice = numbers.slice(0, Math.min(numbers.length, 30));
            if (volSlice.length >= 15) {
                const stdDevVol = calculateStdDev(volSlice, volSlice.length);
                if (stdDevVol !== null) {
                    details += ` VolStdDev:${stdDevVol.toFixed(2)}`;
                    if (stdDevVol > 3.2) volatility = "HIGH";
                    else if (stdDevVol > 1.9) volatility = "MEDIUM";
                    else if (stdDevVol > 0.8) volatility = "LOW";
                    else volatility = "VERY_LOW";
                }
            }
            return { strength, direction, volatility, details, macroRegime: "UNKNOWN_REGIME", isTransitioning: false };
        }

        function analyzeTransitions(history, baseWeight) {
            if (!Array.isArray(history) || history.length < 15) return null;
            const transitions = { "BIG": { "BIG": 0, "SMALL": 0, "total": 0 }, "SMALL": { "BIG": 0, "SMALL": 0, "total": 0 } };
            for (let i = 0; i < history.length - 1; i++) {
                const currentBS = getBigSmallFromNumber(history[i]?.actual);
                const prevBS = getBigSmallFromNumber(history[i + 1]?.actual);
                if (currentBS && prevBS && transitions[prevBS]) {
                    transitions[prevBS][currentBS]++;
                    transitions[prevBS].total++;
                }
            }
            const lastOutcome = getBigSmallFromNumber(history[0]?.actual);
            if (!lastOutcome || !transitions[lastOutcome] || transitions[lastOutcome].total < 6) return null;
            const nextBigProb = transitions[lastOutcome]["BIG"] / transitions[lastOutcome].total;
            const nextSmallProb = transitions[lastOutcome]["SMALL"] / transitions[lastOutcome].total;
            if (nextBigProb > nextSmallProb + 0.35) return { prediction: "BIG", weight: baseWeight * nextBigProb, source: "Transition" };
            if (nextSmallProb > nextBigProb + 0.35) return { prediction: "SMALL", weight: baseWeight * nextSmallProb, source: "Transition" };
            return null;
        }

        function analyzeStreaks(history, baseWeight) {
            if (!Array.isArray(history) || history.length < 3) return null;
            const actuals = history.map(p => getBigSmallFromNumber(p.actual)).filter(bs => bs);
            if (actuals.length < 3) return null;
            let currentStreakType = actuals[0], currentStreakLength = 0;
            for (const outcome of actuals) {
                if (outcome === currentStreakType) currentStreakLength++; else break;
            }
            if (currentStreakLength >= 2) {
                const prediction = getOppositeOutcome(currentStreakType);
                const weightFactor = Math.min(0.5 + (currentStreakLength * 0.20), 0.95);
                return { prediction, weight: baseWeight * weightFactor, source: `StreakBreak-${currentStreakLength}` };
            }
            return null;
        }

        function analyzeMACD(history, shortPeriod, longPeriod, signalPeriod, baseWeight) {
            if (shortPeriod <=0 || longPeriod <=0 || signalPeriod <=0 || shortPeriod >= longPeriod) return null;
            const actualNumbers = history.map(entry => parseInt(entry.actualNumber || entry.actual)).filter(num => !isNaN(num));
            if (actualNumbers.length < longPeriod + signalPeriod -1) return null;

            const emaShort = calculateEMA(actualNumbers, shortPeriod);
            const emaLong = calculateEMA(actualNumbers, longPeriod);

            if (emaShort === null || emaLong === null) return null;
            const macdLineCurrent = emaShort - emaLong;

            const macdLineValues = [];
            for (let i = longPeriod -1; i < actualNumbers.length; i++) {
                const currentSlice = actualNumbers.slice(actualNumbers.length - 1 - i);
                const shortE = calculateEMA(currentSlice, shortPeriod);
                const longE = calculateEMA(currentSlice, longPeriod);
                if (shortE !== null && longE !== null) {
                    macdLineValues.push(shortE - longE);
                }
            }

            if (macdLineValues.length < signalPeriod) return null;

            const signalLine = calculateEMA(macdLineValues.slice().reverse(), signalPeriod);
            if (signalLine === null) return null;

            const macdHistogram = macdLineCurrent - signalLine;
            let prediction = null;

            if (macdLineValues.length >= signalPeriod + 1) {
                const prevMacdSliceForSignal = macdLineValues.slice(0, -1);
                const prevSignalLine = calculateEMA(prevMacdSliceForSignal.slice().reverse(), signalPeriod);
                const prevMacdLine = macdLineValues[macdLineValues.length - 2];

                if (prevSignalLine !== null && prevMacdLine !== null) {
                    if (prevMacdLine <= prevSignalLine && macdLineCurrent > signalLine) prediction = "BIG";
                    else if (prevMacdLine >= prevSignalLine && macdLineCurrent < signalLine) prediction = "SMALL";
                }
            }

            if (!prediction) {
                if (macdHistogram > 0.20) prediction = "BIG";
                else if (macdHistogram < -0.20) prediction = "SMALL";
            }

            if (prediction) {
                const strengthFactor = Math.min(Math.abs(macdHistogram) / 0.5, 1.0);
                return { prediction, weight: baseWeight * (0.6 + strengthFactor * 0.4), source: `MACD` };
            }
            return null;
        }

        function analyzeBollingerBands(history, period, stdDevMultiplier, baseWeight) {
            if (period <= 0) return null;
            const actualNumbers = history.map(entry => parseInt(entry.actualNumber || entry.actual)).filter(num => !isNaN(num));
            if (actualNumbers.length < period) return null;

            const sma = calculateSMA(actualNumbers.slice(0, period), period);
            if (sma === null) return null;

            const stdDev = calculateStdDev(actualNumbers, period);
            if (stdDev === null || stdDev < 0.05) return null;

            const upperBand = sma + (stdDev * stdDevMultiplier);
            const lowerBand = sma - (stdDev * stdDevMultiplier);
            const lastNumber = actualNumbers[0];
            let prediction = null;

            if (lastNumber > upperBand) prediction = "SMALL";
            else if (lastNumber < lowerBand) prediction = "BIG";

            if (prediction) {
                const bandBreachStrength = Math.abs(lastNumber - sma) / (stdDev * stdDevMultiplier + 0.001);
                return { prediction, weight: baseWeight * (0.7 + Math.min(bandBreachStrength, 1.0)*0.3), source: "Bollinger" };
            }
            return null;
        }

        function analyzeFractalDimension(history, baseWeight) {
            const numbers = history.map(e => parseInt(e.actualNumber || e.actual)).filter(n => !isNaN(n));
            if (numbers.length < 100) return null; 

            const logReturns = [];
            for (let i = 1; i < numbers.length; i++) {
                if (numbers[i - 1] > 0) {
                    logReturns.push(Math.log(numbers[i] / numbers[i - 1]));
                }
            }

            if (logReturns.length < 99) return null;

            const nValues = [10, 20, 30, 40, 50]; 
            const logRs = [];
            const logN = [];

            for (const n of nValues) {
                if (logReturns.length < n) continue;
                const rescaledRanges = [];
                for (let i = 0; i <= logReturns.length - n; i++) {
                    const chunk = logReturns.slice(i, i + n);
                    const mean = chunk.reduce((a, b) => a + b, 0) / n;
                    const meanAdjusted = chunk.map(x => x - mean);
                    const cumulativeDev = meanAdjusted.reduce((acc, val) => [...acc, (acc.length > 0 ? acc[acc.length - 1] : 0) + val], []);
                    const range = Math.max(...cumulativeDev) - Math.min(...cumulativeDev);
                    const stdDev = Math.sqrt(chunk.map(x => (x - mean) ** 2).reduce((a, b) => a + b, 0) / n);
                    if (stdDev > 1e-6) {
                        rescaledRanges.push(range / stdDev);
                    }
                }
                if (rescaledRanges.length > 0) {
                    const avgRs = rescaledRanges.reduce((a, b) => a + b, 0) / rescaledRanges.length;
                    logRs.push(Math.log(avgRs));
                    logN.push(Math.log(n));
                }
            }

            if (logN.length < 2) return null;

            const n_fd = logN.length;
            const sumX = logN.reduce((a, b) => a + b, 0);
            const sumY = logRs.reduce((a, b) => a + b, 0);
            const sumXY = logN.reduce((sum, x, i) => sum + x * logRs[i], 0);
            const sumX2 = logN.reduce((sum, x) => sum + x * x, 0);

            const hurst = (n_fd * sumXY - sumX * sumY) / (n_fd * sumX2 - sumX * sumX);
            if (isNaN(hurst)) return null;

            let prediction = null;
            let strengthFactor = Math.abs(hurst - 0.5) * 2; 

            if (hurst > 0.55) { 
                const lastMove = getBigSmallFromNumber(numbers[0]) === getBigSmallFromNumber(numbers[1]) ? getBigSmallFromNumber(numbers[0]) : null;
                if (lastMove) prediction = lastMove; 
            } else if (hurst < 0.45) { 
                const lastMove = getBigSmallFromNumber(numbers[0]);
                if (lastMove) prediction = getOppositeOutcome(lastMove);
            }

            if (prediction) {
                return { prediction, weight: baseWeight * strengthFactor, source: `FractalDim(H:${hurst.toFixed(2)})` };
            }
            return null;
        }

        function analyzeBayesianInference(signals, baseWeight) {
            if (!signals || signals.length < 3) return null;

            let posteriorBig = 0.5;
            let posteriorSmall = 0.5;

            signals.forEach(signal => {
                const reliability = Math.min(Math.max(signal.adjustedWeight * 5, 0.1), 0.9); 

                let p_evidence_given_big, p_evidence_given_small;

                if (signal.prediction === "BIG") {
                    p_evidence_given_big = reliability;
                    p_evidence_given_small = 1 - reliability;
                } else { 
                    p_evidence_given_big = 1 - reliability;
                    p_evidence_given_small = reliability;
                }

                const p_evidence = p_evidence_given_big * posteriorBig + p_evidence_given_small * posteriorSmall;
                if (p_evidence > 0) {
                    posteriorBig = (p_evidence_given_big * posteriorBig) / p_evidence;
                    posteriorSmall = (p_evidence_given_small * posteriorSmall) / p_evidence;
                }
            });

            let prediction = null;
            let strengthFactor = 0;

            if (posteriorBig > 0.75) {
                prediction = "BIG";
                strengthFactor = (posteriorBig - 0.5) * 2;
            } else if (posteriorSmall > 0.75) {
                prediction = "SMALL";
                strengthFactor = (posteriorSmall - 0.5) * 2;
            }

            if (prediction) {
                return { prediction, weight: baseWeight * strengthFactor, source: `Bayesian(P:${prediction === 'BIG' ? posteriorBig.toFixed(2) : posteriorSmall.toFixed(2)})` };
            }
            return null;
        }

        function analyzeQuantumTunneling(history, trendContext, baseWeight) {
            if (trendContext.volatility !== 'VERY_LOW' || history.length < 20) return null;

            const numbers = history.slice(0, 15).map(e => parseInt(e.actualNumber || e.actual));
            const recentMean = calculateSMA(numbers, 15);

            const isNearBoundary = recentMean > 4.0 && recentMean < 5.0;
            if (!isNearBoundary) return null;

            const stdDev = calculateStdDev(numbers, 15);
            if (stdDev === null || stdDev > 1.0) return null;

            const last5Mean = calculateSMA(numbers, 5);
            let prediction = null;
            if (last5Mean > recentMean + stdDev * 0.5) {
                prediction = "BIG"; 
            } else if (last5Mean < recentMean - stdDev * 0.5) {
                prediction = "SMALL"; 
            }

            if (prediction) {
                const strengthFactor = 1.0 - (stdDev / 1.0); 
                return { prediction, weight: baseWeight * strengthFactor, source: `Q-Tunnel(V:${stdDev.toFixed(2)})` };
            }
            return null;
        }

        function analyzeMLModelSignal_Standard(features, baseWeight) {
            if (!features) return null;
            const { rsi_14, macd_hist, trend_strength, hurst } = features;

            let modelConfidence = 0;
            let prediction = null;

            if (rsi_14 > 72 && macd_hist < -0.15 && trend_strength < 2 && hurst < 0.5) {
                prediction = "SMALL";
                modelConfidence = Math.abs(macd_hist) + (rsi_14 - 70) / 30;
            } else if (rsi_14 < 28 && macd_hist > 0.15 && trend_strength < 2 && hurst < 0.5) {
                prediction = "BIG";
                modelConfidence = Math.abs(macd_hist) + (30 - rsi_14) / 30;
            } else if (trend_strength > 0 && macd_hist > 0.25 && hurst > 0.5) {
                prediction = "BIG";
                modelConfidence = 0.6 + trend_strength * 0.2;
            } else if (trend_strength < 0 && macd_hist < -0.25 && hurst > 0.5) {
                prediction = "SMALL";
                modelConfidence = 0.6 + Math.abs(trend_strength) * 0.2;
            }


            if (prediction) {
                const weight = baseWeight * Math.min(1.0, modelConfidence) * 1.4;
                return { prediction, weight: weight, source: "ML-Standard" };
            }
            return null;
        }

        function analyzeMLModelSignal_Volatile(features, baseWeight) {
            if (!features) return null;
            const { rsi_14, stddev_30, bollinger_pct } = features;

            let modelConfidence = 0;
            let prediction = null;

            if (stddev_30 > 2.8) {
                if (rsi_14 > 82 || bollinger_pct > 1.1) {
                    prediction = "SMALL";
                    modelConfidence = ((rsi_14 - 80) / 20) + ((bollinger_pct - 1) * 2);
                } else if (rsi_14 < 18 || bollinger_pct < -0.1) {
                    prediction = "BIG";
                    modelConfidence = ((20 - rsi_14) / 20) + (Math.abs(bollinger_pct) * 2);
                }
            }

            if (prediction) {
                const weight = baseWeight * Math.min(1.0, modelConfidence) * 1.6;
                return { prediction, weight: weight, source: "ML-Volatile" };
            }
            return null;
        }

        function analyzeAdvancedEnsembleML(ml_std_output, ml_vol_output, trendContext, baseWeight) {
            if (!ml_std_output && !ml_vol_output) return null;

            let big_evidence = 0;
            let small_evidence = 0;

            if (ml_std_output) {
                if (ml_std_output.prediction === 'BIG') big_evidence += ml_std_output.weight;
                else small_evidence += ml_std_output.weight;
            }
            if (ml_vol_output) {
                if (ml_vol_output.prediction === 'BIG') big_evidence += ml_vol_output.weight;
                else small_evidence += ml_vol_output.weight;
            }

            if (ml_std_output?.prediction === ml_vol_output?.prediction) {
                if (ml_std_output.prediction === 'BIG') big_evidence *= 2.0;
                else small_evidence *= 2.0;
            }

            if (trendContext.strength === 'STRONG') {
                if (trendContext.direction.includes('BIG') && ml_std_output?.prediction === 'BIG') {
                    big_evidence *= 1.5;
                } else if (trendContext.direction.includes('SMALL') && ml_std_output?.prediction === 'SMALL') {
                    small_evidence *= 1.5;
                }
            }

            if (big_evidence > small_evidence * 1.2) {
                const confidence = big_evidence / (big_evidence + small_evidence);
                return { prediction: 'BIG', weight: baseWeight * confidence, source: 'ML-Ensemble' };
            } else if (small_evidence > big_evidence * 1.2) {
                const confidence = small_evidence / (big_evidence + small_evidence);
                return { prediction: 'SMALL', weight: baseWeight * confidence, source: 'ML-Ensemble' };
            }

            return null;
        }

        function analyzeTrendStability(history) {
            if (!Array.isArray(history) || history.length < 25) {
                return { isStable: true, reason: "Not enough data for stability check.", details: "", dominance: "NONE" };
            }
            const confirmedHistory = history.filter(p => p && (p.status === "Win" || p.status === "Loss") && typeof p.actual !== 'undefined' && p.actual !== null);
            if (confirmedHistory.length < 20) return { isStable: true, reason: "Not enough confirmed results.", details: `Confirmed: ${confirmedHistory.length}`, dominance: "NONE" };

            const recentResults = confirmedHistory.slice(0, 20).map(p => getBigSmallFromNumber(p.actual)).filter(r => r);
            if (recentResults.length < 18) return { isStable: true, reason: "Not enough valid B/S for stability.", details: `Valid B/S: ${recentResults.length}`, dominance: "NONE" };

            const bigCount = recentResults.filter(r => r === "BIG").length;
            const smallCount = recentResults.filter(r => r === "SMALL").length;
            let outcomeDominance = "NONE";

            if (bigCount / recentResults.length >= 0.78) {
                outcomeDominance = "BIG_DOMINANCE";
                return { isStable: false, reason: "Unstable: Extreme Outcome Dominance", details: `BIG:${bigCount}, SMALL:${smallCount} in last ${recentResults.length}`, dominance: outcomeDominance };
            }
            if (smallCount / recentResults.length >= 0.78) {
                outcomeDominance = "SMALL_DOMINANCE";
                return { isStable: false, reason: "Unstable: Extreme Outcome Dominance", details: `BIG:${bigCount}, SMALL:${smallCount} in last ${recentResults.length}`, dominance: outcomeDominance };
            }

            const entropy = calculateEntropyForSignal(recentResults, recentResults.length);
            if (entropy !== null && entropy < 0.5) {
                return { isStable: false, reason: "Unstable: Very Low Entropy (Stuck)", details: `Entropy: ${entropy.toFixed(2)}`, dominance: outcomeDominance };
            }

            const actualNumbersRecent = confirmedHistory.slice(0, 15).map(p => parseInt(p.actualNumber || p.actual)).filter(n => !isNaN(n));
            if (actualNumbersRecent.length >= 10) {
                const stdDevNum = calculateStdDev(actualNumbersRecent, actualNumbersRecent.length);
                if (stdDevNum !== null && stdDevNum > 3.4) {
                    return { isStable: false, reason: "Unstable: High Numerical Volatility", details: `StdDev: ${stdDevNum.toFixed(2)}`, dominance: outcomeDominance };
                }
            }
            let alternations = 0;
            for (let i = 0; i < recentResults.length - 1; i++) {
                if (recentResults[i] !== recentResults[i + 1]) alternations++;
            }
            if (alternations / recentResults.length > 0.80) {
                return { isStable: false, reason: "Unstable: Excessive Choppiness", details: `Alternations: ${alternations}/${recentResults.length}`, dominance: outcomeDominance };
            }

            return { isStable: true, reason: "Trend appears stable.", details: `Entropy: ${entropy !== null ? entropy.toFixed(2) : 'N/A'}`, dominance: outcomeDominance };
        }

        function calculateEntropyForSignal(outcomes, windowSize) {
            if (!Array.isArray(outcomes) || outcomes.length < windowSize) return null;
            const counts = { BIG: 0, SMALL: 0 };
            outcomes.slice(0, windowSize).forEach(o => { if (o) counts[o] = (counts[o] || 0) + 1; });
            let entropy = 0;
            const totalValidOutcomes = counts.BIG + counts.SMALL;
            if (totalValidOutcomes === 0) return 1;
            for (let key in counts) {
                if (counts[key] > 0) { const p = counts[key] / totalValidOutcomes; entropy -= p * Math.log2(p); }
            }
            return isNaN(entropy) ? 1 : entropy;
        }

        function analyzeMarketEntropyState(history, trendContext, stability) {
            const ENTROPY_WINDOW_SHORT = 12;
            const ENTROPY_WINDOW_LONG = 30;
            const VOL_CHANGE_THRESHOLD = 0.35; 

            if (history.length < ENTROPY_WINDOW_LONG) return { state: "UNCERTAIN_ENTROPY", details: "Insufficient history for entropy state." };

            const outcomesShort = history.slice(0, ENTROPY_WINDOW_SHORT).map(e => getBigSmallFromNumber(e.actual));
            const outcomesLong = history.slice(0, ENTROPY_WINDOW_LONG).map(e => getBigSmallFromNumber(e.actual));

            const entropyShort = calculateEntropyForSignal(outcomesShort, ENTROPY_WINDOW_SHORT);
            const entropyLong = calculateEntropyForSignal(outcomesLong, ENTROPY_WINDOW_LONG);

            const numbersShort = history.slice(0, ENTROPY_WINDOW_SHORT).map(e => parseInt(e.actualNumber || e.actual)).filter(n => !isNaN(n));
            const numbersLongPrev = history.slice(ENTROPY_WINDOW_SHORT, ENTROPY_WINDOW_SHORT + ENTROPY_WINDOW_SHORT).map(e => parseInt(e.actualNumber || e.actual)).filter(n => !isNaN(n));

            let shortTermVolatility = null, prevShortTermVolatility = null;
            if(numbersShort.length >= ENTROPY_WINDOW_SHORT * 0.8) shortTermVolatility = calculateStdDev(numbersShort, numbersShort.length);
            if(numbersLongPrev.length >= ENTROPY_WINDOW_SHORT * 0.8) prevShortTermVolatility = calculateStdDev(numbersLongPrev, numbersLongPrev.length);


            let state = "STABLE_MODERATE"; 
            let details = `E_S:${entropyShort?.toFixed(2)} E_L:${entropyLong?.toFixed(2)} Vol_S:${shortTermVolatility?.toFixed(2)} Vol_P:${prevShortTermVolatility?.toFixed(2)}`;

            if (entropyShort === null || entropyLong === null) return { state: "UNCERTAIN_ENTROPY", details };

            if (entropyShort < 0.45 && entropyLong < 0.55 && shortTermVolatility !== null && shortTermVolatility < 1.2) {
                state = "ORDERLY";
            }
            else if (entropyShort > 0.96 && entropyLong > 0.92) {
                if (shortTermVolatility && prevShortTermVolatility && shortTermVolatility > prevShortTermVolatility * (1 + VOL_CHANGE_THRESHOLD) && shortTermVolatility > 2.8) {
                    state = "RISING_CHAOS";
                } else {
                    state = "STABLE_CHAOS";
                }
            }
            else if (shortTermVolatility && prevShortTermVolatility) {
                if (shortTermVolatility > prevShortTermVolatility * (1 + VOL_CHANGE_THRESHOLD) && entropyShort > 0.9 && shortTermVolatility > 2.2) {
                    state = "RISING_CHAOS";
                } else if (shortTermVolatility < prevShortTermVolatility * (1 - VOL_CHANGE_THRESHOLD) && entropyLong > 0.9 && entropyShort < 0.85) {
                    state = "SUBSIDING_CHAOS";
                }
            }

            if (!stability.isStable && (state === "ORDERLY" || state === "STABLE_MODERATE")) {
                state = "POTENTIAL_CHAOS_FROM_INSTABILITY";
                details += ` | StabilityOverride: ${stability.reason}`;
            }
            return { state, details };
        }

        let signalPerformance = {};
        const PERFORMANCE_WINDOW = 30;
        const SESSION_PERFORMANCE_WINDOW = 15;
        const MIN_OBSERVATIONS_FOR_ADJUST = 10;
        const MAX_WEIGHT_FACTOR = 1.95;
        const MIN_WEIGHT_FACTOR = 0.05;
        const MAX_ALPHA_FACTOR = 1.6;
        const MIN_ALPHA_FACTOR = 0.4;
        const MIN_ABSOLUTE_WEIGHT = 0.0003;
        const INACTIVITY_PERIOD_FOR_DECAY = PERFORMANCE_WINDOW * 3;
        const DECAY_RATE = 0.025;
        const ALPHA_UPDATE_RATE = 0.04;
        const PROBATION_THRESHOLD_ACCURACY = 0.40;
        const PROBATION_MIN_OBSERVATIONS = 15;
        const PROBATION_WEIGHT_CAP = 0.10;
        let driftDetector = { p_min: Infinity, s_min: Infinity, n: 0, warning_level: 2.0, drift_level: 2.5 }; 

        function getDynamicWeightAdjustment(signalSourceName, baseWeight, currentPeriodFull, currentVolatilityRegime, sessionHistory) {
            const perf = signalPerformance[signalSourceName];
            if (!perf) {
                signalPerformance[signalSourceName] = {
                    correct: 0, total: 0, recentAccuracy: [],
                    sessionCorrect: 0, sessionTotal: 0,
                    lastUpdatePeriod: null, lastActivePeriod: null,
                    currentAdjustmentFactor: 1.0, alphaFactor: 1.0, longTermImportanceScore: 0.5,
                    performanceByVolatility: {}, isOnProbation: false
                };
                return Math.max(baseWeight, MIN_ABSOLUTE_WEIGHT);
            }

            if (sessionHistory.length <= 1) {
                perf.sessionCorrect = 0;
                perf.sessionTotal = 0;
            }

            if (perf.lastUpdatePeriod !== currentPeriodFull) {
                if (perf.lastActivePeriod !== null && (currentPeriodFull - perf.lastActivePeriod) > INACTIVITY_PERIOD_FOR_DECAY) {
                    if (perf.currentAdjustmentFactor > 1.0) perf.currentAdjustmentFactor = Math.max(1.0, perf.currentAdjustmentFactor - DECAY_RATE);
                    else if (perf.currentAdjustmentFactor < 1.0) perf.currentAdjustmentFactor = Math.min(1.0, perf.currentAdjustmentFactor + DECAY_RATE);
                    if (perf.isOnProbation) perf.isOnProbation = false;
                }
                perf.lastUpdatePeriod = currentPeriodFull;
            }

            let volatilitySpecificAdjustment = 1.0;
            if (perf.performanceByVolatility[currentVolatilityRegime] && perf.performanceByVolatility[currentVolatilityRegime].total >= MIN_OBSERVATIONS_FOR_ADJUST / 2.0) {
                const volPerf = perf.performanceByVolatility[currentVolatilityRegime];
                const volAccuracy = volPerf.correct / volPerf.total;
                const volDeviation = volAccuracy - 0.5;
                volatilitySpecificAdjustment = 1 + (volDeviation * 1.30);
                volatilitySpecificAdjustment = Math.min(Math.max(volatilitySpecificAdjustment, 0.55), 1.45);
            }

            let sessionAdjustmentFactor = 1.0;
            if (perf.sessionTotal >= 3) {
                const sessionAccuracy = perf.sessionCorrect / perf.sessionTotal;
                const sessionDeviation = sessionAccuracy - 0.5;
                sessionAdjustmentFactor = 1 + (sessionDeviation * 1.5);
                sessionAdjustmentFactor = Math.min(Math.max(sessionAdjustmentFactor, 0.6), 1.4);
            }

            let finalAdjustmentFactor = perf.currentAdjustmentFactor * perf.alphaFactor * volatilitySpecificAdjustment * sessionAdjustmentFactor * (0.70 + perf.longTermImportanceScore * 0.6);

            if (perf.isOnProbation) {
                finalAdjustmentFactor = Math.min(finalAdjustmentFactor, PROBATION_WEIGHT_CAP);
            }

            let adjustedWeight = baseWeight * finalAdjustmentFactor;
            return Math.max(adjustedWeight, MIN_ABSOLUTE_WEIGHT);
        }

        function updateSignalPerformance(contributingSignals, actualOutcome, periodFull, currentVolatilityRegime, lastFinalConfidence, concentrationModeActive, marketEntropyState) {
            if (!actualOutcome || !contributingSignals || contributingSignals.length === 0) return;
            const isHighConfidencePrediction = lastFinalConfidence > 0.75;
            const isOverallCorrect = getBigSmallFromNumber(actualOutcome) === currentSharedStats.lastPredictedOutcome; // Corrected: Use lastPredictedOutcome

            contributingSignals.forEach(signal => {
                if (!signal || !signal.source) return;
                const source = signal.source;
                if (!signalPerformance[source]) {
                    signalPerformance[source] = {
                        correct: 0, total: 0, recentAccuracy: [],
                        sessionCorrect: 0, sessionTotal: 0,
                        lastUpdatePeriod: null, lastActivePeriod: null,
                        currentAdjustmentFactor: 1.0, alphaFactor: 1.0, longTermImportanceScore: 0.5,
                        performanceByVolatility: {}, isOnProbation: false
                    };
                }

                if (!signalPerformance[source].performanceByVolatility[currentVolatilityRegime]) {
                    signalPerformance[source].performanceByVolatility[currentVolatilityRegime] = { correct: 0, total: 0 };
                }

                if (signalPerformance[source].lastActivePeriod !== periodFull || signalPerformance[source].total === 0) {
                    signalPerformance[source].total++;
                    signalPerformance[source].sessionTotal++;
                    signalPerformance[source].performanceByVolatility[currentVolatilityRegime].total++;
                    let outcomeCorrect = (signal.prediction === getBigSmallFromNumber(actualOutcome)) ? 1 : 0; // Corrected: use getBigSmallFromNumber
                    if (outcomeCorrect) {
                        signalPerformance[source].correct++;
                        signalPerformance[source].sessionCorrect++;
                        signalPerformance[source].performanceByVolatility[currentVolatilityRegime].correct++;
                    }

                    let importanceDelta = 0;
                    if(outcomeCorrect) {
                        importanceDelta = isHighConfidencePrediction ? 0.025 : 0.01;
                    } else {
                        importanceDelta = isHighConfidencePrediction && !isOverallCorrect ? -0.040 : -0.015;
                    }

                    if (concentrationModeActive || marketEntropyState.includes("CHAOS")) {
                        importanceDelta *= 1.5;
                    }
                    signalPerformance[source].longTermImportanceScore = Math.min(1.0, Math.max(0.0, signalPerformance[source].longTermImportanceScore + importanceDelta));

                    signalPerformance[source].recentAccuracy.push(outcomeCorrect);
                    if (signalPerformance[source].recentAccuracy.length > PERFORMANCE_WINDOW) {
                        signalPerformance[source].recentAccuracy.shift();
                    }

                    if (signalPerformance[source].total >= MIN_OBSERVATIONS_FOR_ADJUST && signalPerformance[source].recentAccuracy.length >= PERFORMANCE_WINDOW / 2) {
                        const recentCorrectCount = signalPerformance[source].recentAccuracy.reduce((sum, acc) => sum + acc, 0);
                        const accuracy = recentCorrectCount / signalPerformance[source].recentAccuracy.length;
                        const deviation = accuracy - 0.5;
                        let newAdjustmentFactor = 1 + (deviation * 3.5);
                        newAdjustmentFactor = Math.min(Math.max(newAdjustmentFactor, MIN_WEIGHT_FACTOR), MAX_WEIGHT_FACTOR);
                        signalPerformance[source].currentAdjustmentFactor = newAdjustmentFactor;

                        if (signalPerformance[source].recentAccuracy.length >= PROBATION_MIN_OBSERVATIONS && accuracy < PROBATION_THRESHOLD_ACCURACY) {
                            signalPerformance[source].isOnProbation = true;
                        } else if (accuracy > PROBATION_THRESHOLD_ACCURACY + 0.15) {
                            signalPerformance[source].isOnProbation = false;
                        }


                        let alphaLearningRate = ALPHA_UPDATE_RATE;
                        if (accuracy < 0.35) alphaLearningRate *= 1.75;
                        else if (accuracy < 0.45) alphaLearningRate *= 1.4;

                        if (newAdjustmentFactor > signalPerformance[source].alphaFactor) {
                            signalPerformance[source].alphaFactor = Math.min(MAX_ALPHA_FACTOR, signalPerformance[source].alphaFactor + alphaLearningRate * (newAdjustmentFactor - signalPerformance[source].alphaFactor));
                        } else {
                            signalPerformance[source].alphaFactor = Math.max(MIN_ALPHA_FACTOR, signalPerformance[source].alphaFactor - alphaLearningRate * (signalPerformance[source].alphaFactor - newAdjustmentFactor));
                        }
                    }
                    signalPerformance[source].lastActivePeriod = periodFull;
                }
                signalPerformance[source].lastUpdatePeriod = periodFull;
            });
        }

        function detectConceptDrift(isCorrect) {
            driftDetector.n++;
            const errorRate = isCorrect ? 0 : 1;
            const p_i = (driftDetector.n > 1 ? driftDetector.p_i : 0) + (errorRate - (driftDetector.n > 1 ? driftDetector.p_i : 0)) / driftDetector.n;
            driftDetector.p_i = p_i;
            const s_i = Math.sqrt(p_i * (1 - p_i) / driftDetector.n);

            if (driftDetector.n > 30 && p_i + s_i < driftDetector.p_min + driftDetector.s_min) {
                driftDetector.p_min = p_i;
                driftDetector.s_min = s_i;
            }

            if (driftDetector.n > 30 && p_i + s_i > driftDetector.p_min + driftDetector.drift_level * driftDetector.s_min) {
                driftDetector.p_min = p_i; 
                driftDetector.s_min = s_i;
                driftDetector.n = 1;
                return 'DRIFT';
            } else if (driftDetector.n > 30 && p_i + s_i > driftDetector.p_min + driftDetector.warning_level * driftDetector.s_min) {
                return 'WARNING';
            } else {
                return 'STABLE';
            }
        }
        
        let REGIME_SIGNAL_PROFILES = {
            "TREND_STRONG_LOW_VOL": { baseWeightMultiplier: 1.30, activeSignalTypes: ['trend', 'momentum', 'fractal', 'ml_standard', 'bayesian'], contextualAggression: 1.35, recentAccuracy: [], totalPredictions: 0, correctPredictions: 0 },
            "TREND_STRONG_MED_VOL": { baseWeightMultiplier: 1.20, activeSignalTypes: ['trend', 'momentum', 'fractal', 'ml_standard', 'bayesian'], contextualAggression: 1.25, recentAccuracy: [], totalPredictions: 0, correctPredictions: 0 },
            "TREND_STRONG_HIGH_VOL": { baseWeightMultiplier: 0.70, activeSignalTypes: ['trend', 'meanRev', 'fractal', 'ml_volatile', 'bayesian'], contextualAggression: 0.70, recentAccuracy: [], totalPredictions: 0, correctPredictions: 0 },
            "RANGE_LOW_VOL": { baseWeightMultiplier: 1.30, activeSignalTypes: ['meanRev', 'pattern', 'q_tunnel', 'fractal', 'ml_standard'], contextualAggression: 1.30, recentAccuracy: [], totalPredictions: 0, correctPredictions: 0 },
            "RANGE_MED_VOL": { baseWeightMultiplier: 1.15, activeSignalTypes: ['meanRev', 'pattern', 'bollinger', 'fractal', 'ml_standard'], contextualAggression: 1.15, recentAccuracy: [], totalPredictions: 0, correctPredictions: 0 },
            "RANGE_HIGH_VOL": { baseWeightMultiplier: 0.85, activeSignalTypes: ['meanRev', 'bollinger', 'ml_volatile', 'bayesian'], contextualAggression: 0.85, recentAccuracy: [], totalPredictions: 0, correctPredictions: 0 },
            "DEFAULT": { baseWeightMultiplier: 0.9, activeSignalTypes: ['all'], contextualAggression: 0.9, recentAccuracy: [], totalPredictions: 0, correctPredictions: 0 }
        };
        const REGIME_ACCURACY_WINDOW = 40;
        const REGIME_LEARNING_RATE_BASE = 0.035; 

        function evolveRegimeProfiles(globalAccuracy) {
            console.log(`EVOLVER: Analyzing regime performance for potential evolution. Global Acc: ${globalAccuracy.toFixed(3)}`);
            const dynamicLearningRate = globalAccuracy < 0.5 ? REGIME_LEARNING_RATE_BASE * 1.5 : REGIME_LEARNING_RATE_BASE;

            for (const regime in REGIME_SIGNAL_PROFILES) {
                if (regime === "DEFAULT") continue;

                const profile = REGIME_SIGNAL_PROFILES[regime];
                if (profile.totalPredictions > 80) { 
                    const longTermAccuracy = profile.correctPredictions / profile.totalPredictions;

                    if (longTermAccuracy < 0.47) {
                        profile.contextualAggression = Math.max(0.4, profile.contextualAggression * (1 - dynamicLearningRate * 2));
                        profile.baseWeightMultiplier = Math.max(0.4, profile.baseWeightMultiplier * (1 - dynamicLearningRate));
                    }
                    else if (longTermAccuracy > 0.56) {
                        profile.baseWeightMultiplier = Math.min(2.2, profile.baseWeightMultiplier * (1 + dynamicLearningRate / 2));
                    }
                }
            }
        }

        function analyzeWaveFunctionCollapse(signals, finalPrediction) {
            if (!signals || signals.length < 5) return { collapsed: false, factor: 1.0 };

            const agreeingSignals = signals.filter(s => s.prediction === finalPrediction);
            const totalWeight = signals.reduce((sum, s) => sum + s.adjustedWeight, 0);
            const agreeingWeight = agreeingSignals.reduce((sum, s) => sum + s.adjustedWeight, 0);

            if (totalWeight === 0) return { collapsed: false, factor: 1.0 };

            const weightRatio = agreeingWeight / totalWeight;

            const signalCategories = new Set(agreeingSignals.map(s => {
                if (s.source.includes("MACD") || s.source.includes("Fractal")) return 'trend';
                if (s.source.includes("RSI") || s.source.includes("Stoch")) return 'momentum';
                if (s.source.includes("Bollinger") || s.source.includes("Streak")) return 'meanRev';
                if (s.source.includes("ML")) return 'ml';
                if (s.source.includes("Bayesian")) return 'probabilistic';
                return 'other';
            }));

            if (weightRatio > 0.85 && signalCategories.size >= 4) {
                return { collapsed: true, factor: 1.8 };
            }

            return { collapsed: false, factor: 1.0 };
        }

        function calculateUncertaintyScore(trendContext, stability, marketEntropyState, pathConfluence, globalAccuracy, isReflexiveCorrection, driftState) {
            let uncertaintyScore = 0;
            let reasons = [];

            if (isReflexiveCorrection) { uncertaintyScore += 100; reasons.push("Reflexive"); }
            if(driftState === 'DRIFT') { uncertaintyScore += 120; reasons.push("Drift"); } 
            else if (driftState === 'WARNING') { uncertaintyScore += 60; reasons.push("DriftWarn"); }
            if (!stability.isStable) { uncertaintyScore += (stability.reason.includes("Dominance") || stability.reason.includes("Choppiness")) ? 60 : 50; reasons.push(`Instability:${stability.reason.substring(0,4)}`); }
            if (marketEntropyState.state.includes("CHAOS")) { uncertaintyScore += marketEntropyState.state === "RISING_CHAOS" ? 55 : 45; reasons.push(marketEntropyState.state); }
            if (pathConfluence.score < 0.65) { uncertaintyScore += (0.65 - pathConfluence.score) * 120; reasons.push(`LowConsistency:${pathConfluence.score.toFixed(2)}`); }
            if (pathConfluence.diversePaths < 3) { uncertaintyScore += (3 - pathConfluence.diversePaths) * 25; reasons.push(`LowConfluence:${pathConfluence.diversePaths}`); }
            if (trendContext.isTransitioning) { uncertaintyScore += 30; reasons.push("Transition"); }
            if (trendContext.volatility === "HIGH") { uncertaintyScore += 25; reasons.push("HighVol"); }
            if (typeof globalAccuracy === 'number' && globalAccuracy < 0.49) { uncertaintyScore += (0.49 - globalAccuracy) * 250; reasons.push(`LowAcc:${globalAccuracy.toFixed(2)}`); }

            return { score: uncertaintyScore, reasons: reasons.join(';') };
        }

        function analyzePathConfluenceStrength(signals, finalPrediction) {
            if (!signals || signals.length === 0 || !finalPrediction) return { score: 0, diversePaths: 0, details: "No valid signals or prediction." };

            const agreeingSignals = signals.filter(s => s.prediction === finalPrediction && s.adjustedWeight > MIN_ABSOLUTE_WEIGHT * 10);
            if (agreeingSignals.length < 2) {
                return { score: 0, diversePaths: agreeingSignals.length, details: "Insufficient agreeing signals." };
            }
            const totalPredictions = signals.filter(s=>s.prediction).length;
            if (totalPredictions === 0) return {score: 0.5, diversePaths: 0};
            const consistencyScore = agreeingSignals.length / totalPredictions;


            const signalCategories = new Set();
            agreeingSignals.forEach(s => {
                if (s.source.includes("MACD") || s.source.includes("Ichimoku")) signalCategories.add('trend');
                else if (s.source.includes("Stochastic") || s.source.includes("RSI")) signalCategories.add('momentum');
                else if (s.source.includes("Bollinger") || s.source.includes("ZScore")) signalCategories.add('meanRev');
                else if (s.source.includes("Gram") || s.source.includes("Cycle") || s.source.includes("Pattern")) signalCategories.add('pattern');
                else if (s.source.includes("Vol") || s.source.includes("FractalDim")) signalCategories.add('volatility');
                else if (s.source.includes("Bayesian") || s.source.includes("Superposition") || s.source.includes("ML-")) signalCategories.add('probabilistic');
                else signalCategories.add('other');
            });

            const diversePathCount = signalCategories.size;

            return { score: consistencyScore, diversePaths: diversePathCount, details: `Paths:${diversePathCount},Strong:${agreeingSignals.length}` };
        }

        let consecutiveHighConfLosses = 0;
        let reflexiveCorrectionActive = 0; 

        function checkForAnomalousPerformance(currentSharedStats) {
            if (reflexiveCorrectionActive > 0) {
                reflexiveCorrectionActive--;
                return true;
            }

            if (currentSharedStats && typeof currentSharedStats.lastFinalConfidence === 'number' && currentSharedStats.lastActualOutcome) {
                const lastPredOutcomeBS = getBigSmallFromNumber(currentSharedStats.lastActualOutcome);
                const lastPredWasCorrect = lastPredOutcomeBS === currentSharedStats.lastPredictedOutcome;

                const lastPredWasHighConf = currentSharedStats.lastConfidenceLevel >= 2; 

                if (lastPredWasHighConf && !lastPredWasCorrect) {
                    consecutiveHighConfLosses++;
                } else {
                    consecutiveHighConfLosses = 0;
                }
            }

            if (consecutiveHighConfLosses >= 2) {
                reflexiveCorrectionActive = 7; 
                consecutiveHighConfLosses = 0;
                return true;
            }

            return false;
        }

        function createFeatureSetForML(history, trendContext, allSignals) {
            const numbers = history.map(e => parseInt(e.actualNumber || e.actual)).filter(n => !isNaN(n));
            if(numbers.length < 100) return null; 

            const hurstResult = analyzeFractalDimension(history, 1.0);
            const macdResult = analyzeMACD(history, 12, 26, 9, 1.0);
            const bollingerResult = analyzeBollingerBands(history, 20, 2.0, 1.0);

            return {
                time_sin: getCurrentISTHour().sin,
                time_cos: getCurrentISTHour().cos,
                last_5_mean: calculateSMA(numbers, 5),
                last_20_mean: calculateSMA(numbers, 20),
                stddev_10: calculateStdDev(numbers, 10),
                stddev_30: calculateStdDev(numbers, 30),
                rsi_14: calculateRSI(numbers, 14),
                macd_hist: macdResult?.macdHistogram || 0,
                trend_strength: trendContext.strength === 'STRONG' ? 2 : (trendContext.strength === 'MODERATE' ? 1 : 0),
                volatility_level: trendContext.volatility === 'HIGH' ? 2 : (trendContext.volatility === 'MEDIUM' ? 1 : 0),
                hurst: hurstResult?.prediction ? (hurstResult.prediction === "BIG" ? 1 : -1) * hurstResult.weight : 0,
                bollinger_pct: bollingerResult ? (bollingerResult.prediction === 'BIG' ? 1 : -1) : 0,
                rsi_x_macd: (calculateRSI(numbers, 14) - 50) * (macdResult?.macdHistogram || 0),
                vol_x_hurst: (calculateStdDev(numbers, 30) || 0) * (hurstResult?.weight || 0)
            };
        }

        const MAX_CONSECUTIVE_SKIPS = 2;

        function ultraAIPredict(currentSharedHistory, sharedStatsPayload) {
            currentSharedStats = sharedStatsPayload || { consecutiveSkips: 0 };
            currentSharedStats.consecutiveSkips = currentSharedStats.consecutiveSkips || 0;

            const currentPeriodFull = currentSharedStats?.periodFull || Date.now();
            const time = getCurrentISTHour();
            const primeTimeSession = getPrimeTimeSession(time.raw);
            const realTimeData = getRealTimeExternalData();

            let longTermGlobalAccuracy = currentSharedStats?.longTermGlobalAccuracy || 0.5;

            if (currentPeriodFull % 150 === 0) { 
                evolveRegimeProfiles(longTermGlobalAccuracy);
            }

            let masterLogic = [`QAScore_v50.2(IST_Hr:${time.raw})`];
            masterLogic.push(realTimeData.reason);

            let primeTimeAggression = 1.0;
            let primeTimeConfidence = 1.0;
            if (primeTimeSession) {
                masterLogic.push(`PRIME:${primeTimeSession.session}`);
                primeTimeAggression = primeTimeSession.aggression;
                primeTimeConfidence = primeTimeSession.confidence;
            }

            const isReflexiveCorrection = checkForAnomalousPerformance(currentSharedStats);
            if (isReflexiveCorrection) masterLogic.push(`REFLEXIVE_CORRECTION(Countdown:${reflexiveCorrectionActive})`);

            const trendContext = getMarketRegimeAndTrendContext(currentSharedHistory);
            masterLogic.push(`Trend(D:${trendContext.direction},S:${trendContext.strength},V:${trendContext.volatility},R:${trendContext.macroRegime})`);

            const stability = analyzeTrendStability(currentSharedHistory);
            const marketEntropyAnalysis = analyzeMarketEntropyState(currentSharedHistory, trendContext, stability);
            masterLogic.push(`Entropy:${marketEntropyAnalysis.state}`);

            let driftState = 'STABLE';
            if (currentSharedStats && typeof currentSharedStats.lastActualOutcome !== 'undefined') {
                const lastPredictionWasCorrect = getBigSmallFromNumber(currentSharedStats.lastActualOutcome) === currentSharedStats.lastPredictedOutcome;
                driftState = detectConceptDrift(lastPredictionWasCorrect);
                if (driftState !== 'STABLE') {
                    masterLogic.push(`DRIFT_DETECTED:${driftState}`);
                    if(driftState === 'DRIFT') signalPerformance = {};
                }
            }

            const confirmedHistory = currentSharedHistory.filter(p => p && p.actual !== null && p.actualNumber !== undefined);
            if (confirmedHistory.length < 100) { 
                masterLogic.push(`InsufficientHistory`);
                const finalDecision = Math.random() > 0.5 ? "BIG" : "SMALL";
                return {
                    finalDecision,
                    finalConfidence: 0.5,
                    confidenceLevel: 1,
                    isForcedPrediction: true,
                    overallLogic: masterLogic.join('->'),
                    source: "InsufficientHistory",
                    contributingSignals: [],
                    currentMacroRegime: trendContext.macroRegime, // Still provide if possible
                    predictionQualityScore: 0.5, // Default safe value
                    uncertaintyScore: 0,       // Default safe value
                    driftState: driftState
                };
            }

            let signals = [];
            const currentRegimeProfile = REGIME_SIGNAL_PROFILES[trendContext.macroRegime] || REGIME_SIGNAL_PROFILES["DEFAULT"];
            let regimeContextualAggression = (currentRegimeProfile.contextualAggression || 1.0) * primeTimeAggression;

            const addSignal = (fn, historyArg, signalType, lookbackParams, baseWeight) => {
                if (!(currentRegimeProfile.activeSignalTypes.includes('all') || currentRegimeProfile.activeSignalTypes.includes(signalType))) return;

                let fnArgs = [historyArg, ...lookbackParams, baseWeight];
                if (fn === analyzeBayesianInference) { 
                    fnArgs = [signals, baseWeight];
                } else if (fn === analyzeQuantumTunneling) {
                    fnArgs = [historyArg, trendContext, baseWeight];
                }

                const result = fn(...fnArgs);
                if (result && result.weight && result.prediction) {
                    result.adjustedWeight = getDynamicWeightAdjustment(result.source, result.weight * regimeContextualAggression, currentPeriodFull, trendContext.volatility, currentSharedHistory);
                    signals.push(result);
                }
            };

            addSignal(analyzeTransitions, confirmedHistory, 'pattern', [], 0.04);
            addSignal(analyzeStreaks, confirmedHistory, 'meanRev', [], 0.05);
            addSignal(analyzeMACD, confirmedHistory, 'trend', [12, 26, 9], 0.09);
            addSignal(analyzeBollingerBands, confirmedHistory, 'meanRev', [20, 2.1], 0.07);
            addSignal(analyzeFractalDimension, confirmedHistory, 'fractal', [], 0.15);
            addSignal(analyzeQuantumTunneling, confirmedHistory, 'q_tunnel', [], 0.12);

            const mlFeatures = createFeatureSetForML(confirmedHistory, trendContext, signals);
            const ml_std_result = mlFeatures ? analyzeMLModelSignal_Standard(mlFeatures, 0.25) : null;
            const ml_vol_result = mlFeatures ? analyzeMLModelSignal_Volatile(mlFeatures, 0.30) : null;
            if (ml_std_result) signals.push(ml_std_result);
            if (ml_vol_result) signals.push(ml_vol_result);

            const ml_ensemble_result = analyzeAdvancedEnsembleML(ml_std_result, ml_vol_result, trendContext, 0.45);
            if (ml_ensemble_result) signals.push(ml_ensemble_result);

            addSignal(analyzeBayesianInference, signals, 'bayesian', [], 0.20);

            const validSignals = signals.filter(s => s?.prediction && s.adjustedWeight > MIN_ABSOLUTE_WEIGHT);
            masterLogic.push(`Signals(${validSignals.length}/${signals.length})`);

            let bigScore = 0; let smallScore = 0;
            validSignals.forEach(signal => {
                if (signal.prediction === "BIG") bigScore += signal.adjustedWeight;
                else if (signal.prediction === "SMALL") smallScore += signal.adjustedWeight;
            });

            const totalScore = bigScore + smallScore;
            let finalDecision = totalScore > 0 ? (bigScore >= smallScore ? "BIG" : "SMALL") : (Math.random() > 0.5 ? "BIG" : "SMALL");
            let finalConfidence = totalScore > 0 ? Math.max(bigScore, smallScore) / totalScore : 0.5;

            const wfc = analyzeWaveFunctionCollapse(validSignals, finalDecision);
            if (wfc.collapsed) {
                masterLogic.push('WAVE_COLLAPSE!');
                finalConfidence = 0.5 + (finalConfidence - 0.5) * wfc.factor;
            }

            finalConfidence = 0.5 + (finalConfidence - 0.5) * primeTimeConfidence * realTimeData.factor;

            const pathConfluence = analyzePathConfluenceStrength(validSignals, finalDecision);
            const uncertainty = calculateUncertaintyScore(trendContext, stability, marketEntropyAnalysis, pathConfluence, longTermGlobalAccuracy, isReflexiveCorrection, driftState);

            const uncertaintyFactor = 1.0 - Math.min(1.0, uncertainty.score / 150.0);
            finalConfidence = 0.5 + (finalConfidence - 0.5) * uncertaintyFactor;
            masterLogic.push(`Uncertainty(S:${uncertainty.score.toFixed(0)},F:${uncertaintyFactor.toFixed(2)})`);

            let pqs = 0.5;
            pqs += (pathConfluence.score - 0.5) * 0.5; 
            pqs += (pathConfluence.diversePaths / 10.0) * 0.2;
            pqs = Math.max(0.01, Math.min(0.99, pqs - (uncertainty.score / 600)));
            masterLogic.push(`PQS:${pqs.toFixed(3)}`);

            let confidenceLevel = 1;
            if (pqs > 0.60 && !isReflexiveCorrection && driftState === 'STABLE') confidenceLevel = 2;
            if ((pqs > 0.75 || wfc.collapsed) && uncertainty.score < 50) confidenceLevel = 3;

            let isForcedPrediction = uncertainty.score >= 120 || pqs < 0.10;

            const shouldSkip = pqs < 0.40 || uncertainty.score > 85;
            if (shouldSkip && currentSharedStats.consecutiveSkips < MAX_CONSECUTIVE_SKIPS) {
                finalDecision = "SKIP";
                confidenceLevel = 0; 
                finalConfidence = 0.5;
                isForcedPrediction = true; 
                masterLogic.push(`SKIP(PQS:${pqs.toFixed(2)},U:${uncertainty.score.toFixed(0)})`);
                currentSharedStats.consecutiveSkips++;
            } else {
                currentSharedStats.consecutiveSkips = 0;
                if (isForcedPrediction) {
                    confidenceLevel = 1;
                    finalConfidence = 0.5 + (Math.random() - 0.5) * 0.02;
                    masterLogic.push(`FORCED_PREDICTION(U:${uncertainty.score.toFixed(0)})`);
                }
            }

            const output = {
                finalDecision,
                finalConfidence,
                confidenceLevel,
                isForcedPrediction,
                overallLogic: masterLogic.join('->'),
                source: "EvolverFusion-v50.2",
                contributingSignals: validSignals.map(s => ({ source: s.source, prediction: s.prediction, weight: s.adjustedWeight.toFixed(5) })).sort((a,b)=>b.weight-a.weight).slice(0, 15),
                currentMacroRegime: trendContext.macroRegime,
                predictionQualityScore: pqs,
                uncertaintyScore: uncertainty.score,
                driftState: driftState
            };

            currentSharedStats = { 
                ...currentSharedStats, 
                ...output, 
                lastPredictedOutcome: finalDecision, 
                lastFinalConfidence: finalConfidence, 
                lastConfidenceLevel: confidenceLevel, 
                lastMacroRegime: trendContext.macroRegime, 
                lastPredictionSignals: validSignals, 
                periodFull: currentPeriodFull, 
                lastActualOutcome: null 
            };

            console.log(`QAScore v50.2 Output: ${output.finalDecision} @ ${(output.finalConfidence * 100).toFixed(1)}% | Lvl:${output.confidenceLevel} | PQS:${output.predictionQualityScore.toFixed(2)} | Skips:${currentSharedStats.consecutiveSkips}`);
            return output;
        }
        // --- PREDICTION LOGIC END ---

        // --- Firebase Data Loading and Saving ---
        async function loadUserDataFromFirebase() {
            if (!currentUserUid) {
                console.warn("loadUserDataFromFirebase called without currentUserUid. Skipping data load.");
                return;
            }

            try {
                const historySnapshot = await get(userHistoryRef);
                if (historySnapshot.exists()) {
                    historyData = historySnapshot.val();
                    if (typeof historyData === 'object' && !Array.isArray(historyData)) {
                        historyData = Object.values(historyData); 
                    }
                    historyData.sort((a, b) => b.period - a.period); 
                } else {
                    historyData = [];
                }

                const settingsSnapshot = await get(userSettingsRef);
                if (settingsSnapshot.exists()) {
                    const settings = settingsSnapshot.val();
                    currentLanguage = settings.language || 'en';
                    isSoundEnabled = settings.isSoundEnabled !== undefined ? settings.isSoundEnabled : true;
                    isNotificationsEnabled = settings.isNotificationsEnabled !== undefined ? settings.isNotificationsEnabled : false;
                    isAdvancedMode = settings.isAdvancedMode !== undefined ? settings.isAdvancedMode : false;
                } else {
                    await saveUserSettingsToFirebase(); // Save defaults if no settings found
                }
                
                applySettingsToUI(); // Apply loaded or default settings to UI
                updateHistory();
                updateStats();

            } catch (error) {
                console.error("Error loading user data from Firebase:", error);
                showToast("Failed to load your personal data. Please refresh.");
            }
        }

        async function saveHistoryToFirebase() {
            if (!currentUserUid) {
                console.warn("saveHistoryToFirebase called without currentUserUid. Skipping data save.");
                return;
            }
            try {
                await set(userHistoryRef, historyData);
                console.log("History saved to Firebase.");
            } catch (error) {
                console.error("Error saving history to Firebase:", error);
            }
        }

        async function saveUserSettingsToFirebase() {
            if (!currentUserUid) {
                console.warn("saveUserSettingsToFirebase called without currentUserUid. Skipping settings save.");
                return;
            }
            const settings = {
                language: currentLanguage,
                isSoundEnabled: isSoundEnabled,
                isNotificationsEnabled: isNotificationsEnabled,
                isAdvancedMode: isAdvancedMode
            };
            try {
                await set(userSettingsRef, settings);
                console.log("User settings saved to Firebase.");
            } catch (error) {
                console.error("Error saving user settings to Firebase:", error);
            }
        }

        // --- Language Update Function ---
        function updateLanguage() {
            document.querySelectorAll('[data-lang-key]').forEach(element => {
                const key = element.getAttribute('data-lang-key');
                if (element) { // Check if element exists
                    element.textContent = translations[currentLanguage][key] || element.textContent;
                }
            });
            // Update confidence text specifically since it has dynamic value
            const confidenceTextElement = document.getElementById('confidenceText');
            const confidenceFillElement = document.getElementById('confidenceFill');
            if (confidenceTextElement && confidenceFillElement) {
                confidenceTextElement.textContent = `${translations[currentLanguage]['confidence_text']} ${confidenceFillElement.style.width}`;
            }
            
            const totalWinsDisplayElement = document.getElementById('settingsTotalWins');
            const statsTotalWinsElement = document.getElementById('statsTotalWins');
            if (totalWinsDisplayElement && statsTotalWinsElement) {
                totalWinsDisplayElement.textContent = `${translations[currentLanguage]['total_wins_display']} ${statsTotalWinsElement.textContent}`;
            }

            const totalLossesDisplayElement = document.getElementById('settingsTotalLosses');
            const statsTotalLossesElement = document.getElementById('statsTotalLosses');
            if (totalLossesDisplayElement && statsTotalLossesElement) {
                totalLossesDisplayElement.textContent = `${translations[currentLanguage]['total_losses_display']} ${statsTotalLossesElement.textContent}`;
            }
        }

        // --- Navigation Logic for Main App ---
        const navItems = document.querySelectorAll('.navigation ul li');
        const sections = document.querySelectorAll('.content-section');

        navItems.forEach(item => {
            item.addEventListener('click', (e) => {
                e.preventDefault();
                navItems.forEach(nav => nav.classList.remove('active'));
                sections.forEach(section => section.classList.remove('active'));
                
                item.classList.add('active');
                const sectionId = item.querySelector('a').getAttribute('data-section');
                document.getElementById(sectionId).classList.add('active');
            });
        });

        // --- Popup and Modal Functions ---
        function openVideoPopup() {
            document.getElementById('videoPopup').classList.add('active');
            if (isSoundEnabled) {
                // new Audio('https://www.soundjay.com/buttons/beep-01a.mp3').play();
            }
        }

        function closeVideoPopup() {
            document.getElementById('videoPopup').classList.remove('active');
            if (isSoundEnabled) {
                // new Audio('https://www.soundjay.com/buttons/beep-02.mp3').play();
            }
        }

        function showWinPopup(period, predicted, actual, predictionType) {
            document.getElementById('winDetails').textContent = `${translations[currentLanguage].period}: ${period} | ${translations[currentLanguage].prediction}: ${predicted} | ${translations[currentLanguage].actual}: ${actual}`;
            document.getElementById('winPopup').classList.add('active');
            if (isSoundEnabled) {
                speak("congratulations You Win power by ORACLE X AI");
            }
            setTimeout(() => {
                document.getElementById('winPopup').classList.remove('active');
            }, 5000);
        }

        function showLossPopup(period, predicted, actual, predictionType) {
            document.getElementById('lossDetails').textContent = `${translations[currentLanguage].period}: ${period} | ${translations[currentLanguage].prediction}: ${predicted} | ${translations[currentLanguage].actual}: ${actual}`;
            document.getElementById('lossPopup').classList.add('active');
            if (isSoundEnabled) {
                speak("Sorry you Loss pattern not stables or my mistake");
            }
            setTimeout(() => {
                document.getElementById('lossPopup').classList.remove('active');
            }, 5000);
        }

        function showPatternWarningPopup() {
            document.getElementById('patternWarningPopup').classList.add('active');
        }

        function showHistoryDeletedPopup(message) {
            document.getElementById('historyDeleteDetails').textContent = message;
            document.getElementById('historyDeletedPopup').classList.add('active');
            if (isSoundEnabled) {
                speak(translations[currentLanguage].history_deleted_message);
            }
            setTimeout(() => {
                document.getElementById('historyDeletedPopup').classList.remove('active');
            }, 3000);
        }

        function speak(text) {
            if ('speechSynthesis' in window) {
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US'; // Always speak English for consistency with AI voice
                utterance.volume = 1;
                utterance.rate = 1;
                utterance.pitch = 1;
                speechSynthesis.speak(utterance);
            }
        }

        function showConfirmModal(message, onConfirm) {
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('confirmModal').classList.add('active');
            const confirmBtn = document.getElementById('confirmModalBtn');
            const cancelBtn = document.getElementById('cancelModalBtn');

            const confirmHandler = () => {
                onConfirm();
                document.getElementById('confirmModal').classList.remove('active');
                confirmBtn.removeEventListener('click', confirmHandler);
                if (isSoundEnabled) {
                    // new Audio('https://www.soundjay.com/buttons/beep-01a.mp3').play();
                }
            };

            confirmBtn.addEventListener('click', confirmHandler);
            cancelBtn.addEventListener('click', () => {
                document.getElementById('confirmModal').classList.remove('active');
                if (isSoundEnabled) {
                    // new Audio('https://www.soundjay.com/buttons/beep-02.mp3').play();
                }
            });
        }

        function showPlayResumeModal() {
            document.getElementById('playResumeModal').classList.add('active');
        }

        function showUnstableTrendPopup() {
            document.getElementById('unstableTrendPopup').classList.add('active');
            isPaused = true;
            isPatternGood = false; // Mark pattern as not good, effectively pausing
            clearInterval(predictionInterval);
            predictionInterval = null;

            unstableTrendTimeRemaining = UNSTABLE_TREND_PAUSE_DURATION_SECONDS;
            updateUnstableTrendCountdownDisplay();

            unstableTrendTimerInterval = setInterval(() => {
                unstableTrendTimeRemaining--;
                updateUnstableTrendCountdownDisplay();
                if (unstableTrendTimeRemaining <= 0) {
                    clearInterval(unstableTrendTimerInterval);
                    unstableTrendTimerInterval = null;
                    document.getElementById('unstableTrendPopup').classList.remove('active');
                    resumePlaying(); // Automatically resume predictions
                }
            }, 1000);

            document.getElementById("currentPredictionResult").firstChild.textContent = translations[currentLanguage].pending; // Use pending/paused
            document.getElementById("predictionLevelDisplay").textContent = ""; // Clear level
            document.getElementById("predictionLevelDisplay").className = "level-badge"; // Reset class
            document.getElementById("predictionTitle").textContent = translations[currentLanguage].prediction;
            showToast(translations[currentLanguage].unstable_trend_message);
        }

        function updateUnstableTrendCountdownDisplay() {
            const minutes = Math.floor(unstableTrendTimeRemaining / 60);
            const seconds = unstableTrendTimeRemaining % 60;
            const formattedTime = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            const countdownElement = document.getElementById('unstableTrendCountdown');
            if (countdownElement) {
                countdownElement.textContent = formattedTime;
            }
        }

        function pausePredictions() {
            // This function is for the 5-consecutive-loss pause, not the unstable trend pause.
            document.getElementById('patternWarningPopup').classList.remove('active');
            clearInterval(predictionInterval);
            predictionInterval = null; 
            isPaused = true;
            isPatternGood = false;
            document.getElementById("currentPredictionResult").firstChild.textContent = translations[currentLanguage].pending; // Use pending/paused
            document.getElementById("predictionLevelDisplay").textContent = ""; // Clear level
            document.getElementById("predictionLevelDisplay").className = "level-badge"; // Reset class
            document.getElementById("predictionTitle").textContent = translations[currentLanguage].prediction;
            // Set timeout for 15 minutes to show resume modal
            setTimeout(() => {
                showPlayResumeModal();
            }, 15 * 60 * 1000); // 15 minutes
            showToast(translations[currentLanguage].pattern_warning_message);
        }

        function resumePlaying() {
            // This function is used to resume from both types of pauses
            document.getElementById('playResumeModal').classList.remove('active');
            document.getElementById('unstableTrendPopup').classList.remove('active'); // Ensure unstable popup is hidden
            
            isPaused = false;
            isPatternGood = true;
            
            if (unstableTrendTimerInterval) { // Clear timer if still running
                clearInterval(unstableTrendTimerInterval);
                unstableTrendTimerInterval = null;
                unstableTrendTimeRemaining = 0;
            }

            if (!predictionInterval) { 
                predictionInterval = setInterval(updatePrediction, 5000);
                updatePrediction(); 
            }
            showToast(translations[currentLanguage].resume_playing_message);
        }

        // --- Settings Handlers ---
        document.getElementById('languageToggle').addEventListener('change', async (e) => {
            currentLanguage = e.target.checked ? 'hi' : 'en';
            await saveUserSettingsToFirebase(); 
            updateLanguage();
        });

        document.getElementById('notificationToggle').addEventListener('change', async (e) => {
            isNotificationsEnabled = e.target.checked;
            await saveUserSettingsToFirebase(); 
            if (isNotificationsEnabled && Notification.permission !== 'granted') {
                Notification.requestPermission();
            }
        });

        document.getElementById('soundToggle').addEventListener('change', async (e) => {
            isSoundEnabled = e.target.checked;
            await saveUserSettingsToFirebase(); 
        });

        document.getElementById('predictionModeToggle').addEventListener('change', async (e) => {
            isAdvancedMode = e.target.checked;
            await saveUserSettingsToFirebase(); 
            updateAdvancedStatusBarVisibility();
        });

        function updateAdvancedStatusBarVisibility() {
            const advancedStatusBarElement = document.getElementById('advancedStatusBar');
            if (advancedStatusBarElement) {
                if (isAdvancedMode) {
                    advancedStatusBarElement.classList.add('active');
                } else {
                    advancedStatusBarElement.classList.remove('active');
                }
            }
        }

        function resetSettings() {
            showConfirmModal(translations[currentLanguage].reset_settings_confirm, async () => {
                currentLanguage = 'en';
                isSoundEnabled = true;
                isNotificationsEnabled = false;
                isAdvancedMode = false;
                await saveUserSettingsToFirebase(); 
                applySettingsToUI(); // Re-apply settings to UI
            });
        }

        function determineColor(number) {
            if (number === 0 || number === 5) return 'VIOLET';
            if ([1, 3, 7, 9].includes(number)) return 'GREEN';
            if ([2, 4, 6, 8].includes(number)) return 'RED';
            return 'UNKNOWN';
        }

        function updateLastStatus(actualNumber, predictionLevel) {
            const currentHistoryEntry = historyData[0];
            let match = false;
            let predictedValue, actualValue;

            const actualSizeType = actualNumber >= 5 ? 'BIG' : 'SMALL';
            const actualColorType = determineColor(actualNumber);

            currentHistoryEntry.result = actualNumber;
            currentHistoryEntry.sizeResultType = actualSizeType;
            currentHistoryEntry.colorResultType = actualColorType;
            currentHistoryEntry.predictionLevel = predictionLevel; // Store the level

            if (currentHistoryEntry.predictionType === 'size') {
                match = (actualSizeType === currentHistoryEntry.sizePrediction);
                predictedValue = currentHistoryEntry.sizePrediction;
                actualValue = actualSizeType;
            } else if (currentHistoryEntry.predictionType === 'color') {
                match = (actualColorType === currentHistoryEntry.colorPrediction);
                predictedValue = currentHistoryEntry.colorPrediction;
                actualValue = actualColorType;
            } else {
                console.error("Unknown prediction type in history entry:", currentHistoryEntry.predictionType);
                return;
            }

            currentHistoryEntry.resultStatus = match ? 'WIN' : 'LOSS';

            if (match) {
                winLevel = Math.min(winLevel + 1, MAX_WIN_LEVEL);
                streak = streak + 1;
                lossStreak = 0;
                consecutiveLosses = 0;
                showWinPopup(currentHistoryEntry.period, predictedValue, actualValue, currentHistoryEntry.predictionType);

                // NEW: Check for unstable trend after a win
                const trendStability = analyzeTrendStability(historyData); // Re-analyze with latest data
                if (!trendStability.isStable) {
                    console.log("Unstable trend detected after a win. Pausing predictions.");
                    showUnstableTrendPopup();
                }
            } else {
                winLevel = 0;
                streak = 0;
                lossStreak += 1;
                consecutiveLosses += 1;
                showLossPopup(currentHistoryEntry.period, predictedValue, actualValue, currentHistoryEntry.predictionType);
                if (consecutiveLosses >= 5) {
                    showPatternWarningPopup();
                }
            }
        }

        async function fetchGameResult() {
            try {
                let response = await fetch("https://api.bdg88zf.com/api/webapi/GetNoaverageEmerdList", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        pageSize: 10,
                        pageNo: 1,
                        typeId: 1,
                        language: 0,
                        random: "4a0522c6ecd8410496260e686be2a57c",
                        signature: "334B5E70A0C9B8918B0B15E517E2069C",
                        timestamp: Math.floor(Date.now() / 1000)
                    })
                });
                let data = await response.json();
                return data?.data?.list?.[0] || null;
            } catch (e) {
                console.error("API Error fetching game result:", e);
                updateServerStatus(false);
                return null;
            }
        }

        function updateServerStatus(isConnected) {
            const statusElement = document.getElementById('serverStatus');
            const indicator = document.getElementById('serverStatusIndicator');
            if (statusElement && indicator) { 
                if (isConnected) {
                    statusElement.textContent = translations[currentLanguage].connected;
                    indicator.classList.add('animate-ping', 'bg-server-status-connected'); 
                    indicator.classList.remove('bg-gray-500');
                } else {
                    statusElement.textContent = translations[currentLanguage].disconnected;
                    indicator.classList.remove('animate-ping', 'bg-server-status-connected');
                    indicator.classList.add('bg-gray-500');
                }
            }
        }

        function showToast(message) {
            const toast = document.createElement("div");
            toast.className = "toast";
            toast.innerText = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        let predictionInterval; 
        
        async function updatePrediction() {
            if (isPaused || !isPatternGood || !currentUserUid) {
                console.log("Prediction skipped: paused, bad pattern, or no user UID.");
                return; 
            }

            let result = await fetchGameResult();
            if (!result || result.issueNumber === lastFetchedPeriod) return;

            updateServerStatus(true);

            if (historyData.length > 0 && historyData[0].resultStatus === "Pending") {
                const actualNumber = Number(result.number);
                updateLastStatus(actualNumber, historyData[0].confidenceLevel); // Pass level to updateLastStatus
                updateHistory();
                updateStats();
                await saveHistoryToFirebase(); 
            }

            const nextPeriodFull = (BigInt(result.issueNumber) + 1n).toString();
            const nextPeriod = nextPeriodFull.slice(-4);

            const aiPredictionOutput = ultraAIPredict(historyData, currentSharedStats);

            let currentPredictionValue = aiPredictionOutput.finalDecision;
            let confidenceValue = (aiPredictionOutput.finalConfidence * 100).toFixed(0);
            let confidenceColorClass = '';
            let predictionLevel = aiPredictionOutput.confidenceLevel; // Get the confidence level

            if (currentPredictionValue === "SKIP") {
                currentPredictionValue = translations[currentLanguage].pending; // Use 'Pending' or a suitable term
                confidenceValue = 0;
                predictionLevel = 0; // Explicitly no level for skipped
                confidenceColorClass = 'light-gray'; // Using a variable from :root
            } else {
                if (currentPredictionType === 'size') {
                    confidenceColorClass = currentPredictionValue === 'BIG' ? 'green' : 'red'; // These resolve to specific color variables in CSS
                    document.getElementById("predictionTitle").textContent = translations[currentLanguage].prediction; // Ensure predictionTitle is updated
                } else { // color
                    confidenceColorClass = currentPredictionValue.toLowerCase(); // Will be 'green', 'red', 'violet'
                    document.getElementById("predictionTitle").textContent = translations[currentLanguage].prediction; // Ensure predictionTitle is updated
                }
            }
            
            const currentPeriodElement = document.getElementById("currentPeriod");
            if (currentPeriodElement) currentPeriodElement.textContent = nextPeriod;
            const currentPredictionResultElement = document.getElementById("currentPredictionResult");
            if (currentPredictionResultElement) currentPredictionResultElement.firstChild.textContent = currentPredictionValue;
            
            const confidenceFillElement = document.getElementById("confidenceFill");
            if (confidenceFillElement) {
                confidenceFillElement.classList.remove('red', 'green', 'violet');
                if (confidenceColorClass) {
                    confidenceFillElement.classList.add(confidenceColorClass);
                }
                confidenceFillElement.style.width = `${confidenceValue}%`;
            }
            const confidenceTextElement = document.getElementById("confidenceText");
            if (confidenceTextElement) confidenceTextElement.textContent = `${translations[currentLanguage].confidence_text} ${confidenceValue}%`;

            const predictionLevelDisplayElement = document.getElementById("predictionLevelDisplay");
            if (predictionLevelDisplayElement) {
                predictionLevelDisplayElement.classList.remove('level-1-badge', 'level-2-badge', 'level-3-badge');
                if (predictionLevel === 1) {
                    predictionLevelDisplayElement.textContent = "Lvl 1";
                    predictionLevelDisplayElement.classList.add('level-1-badge');
                } else if (predictionLevel === 2) {
                    predictionLevelDisplayElement.textContent = "Lvl 2";
                    predictionLevelDisplayElement.classList.add('level-2-badge');
                } else if (predictionLevel === 3) {
                    predictionLevelDisplayElement.textContent = "Lvl 3";
                    predictionLevelDisplayElement.classList.add('level-3-badge');
                } else {
                    predictionLevelDisplayElement.textContent = "";
                }
            }

            // Update Advanced Status Bar
            const advancedStatusBarElement = document.getElementById('advancedStatusBar');
            if (advancedStatusBarElement && isAdvancedMode) {
                let statusContent = `
                    <span class="${aiPredictionOutput.predictionQualityScore > 0.6 ? 'good' : (aiPredictionOutput.predictionQualityScore < 0.4 ? 'danger' : 'warning')}">PQS: ${aiPredictionOutput.predictionQualityScore.toFixed(2)}</span>
                    <span class="${aiPredictionOutput.uncertaintyScore < 50 ? 'good' : (aiPredictionOutput.uncertaintyScore > 100 ? 'danger' : 'warning')}">Uncertainty: ${aiPredictionOutput.uncertaintyScore.toFixed(0)}</span>
                    <span class="info">Regime: ${aiPredictionOutput.currentMacroRegime}</span>
                    <span class="${aiPredictionOutput.driftState === 'STABLE' ? 'good' : (aiPredictionOutput.driftState === 'WARNING' ? 'warning' : 'danger')}">Drift: ${aiPredictionOutput.driftState}</span>
                `;
                advancedStatusBarElement.innerHTML = statusContent;
            }


            historyData.unshift({
                period: nextPeriod,
                predictionType: currentPredictionType,
                sizePrediction: (currentPredictionType === 'size' ? currentPredictionValue : 'N/A'),
                colorPrediction: (currentPredictionType === 'color' ? currentPredictionValue : 'N/A'),
                result: "-",
                sizeResultType: "Pending",
                colorResultType: "Pending",
                resultStatus: "Pending",
                confidence: confidenceValue,
                confidenceLevel: predictionLevel, // Store the level
                predictionQualityScore: aiPredictionOutput.predictionQualityScore,
                uncertaintyScore: aiPredictionOutput.uncertaintyScore
            });

            if (historyData.length > 20) { historyData.pop(); }
            await saveHistoryToFirebase(); 

            predictionSwitchCounter++;
            if (predictionSwitchCounter >= PREDICTION_SWITCH_THRESHOLD) {
                currentPredictionType = (currentPredictionType === 'size' ? 'color' : 'size');
                predictionSwitchCounter = 0;
            }

            updateHistory();
            updateStats();
            lastFetchedPeriod = result.issueNumber;

            if (isNotificationsEnabled && Notification.permission === 'granted') {
                if (currentPredictionType === 'size') {
                    new Notification(`${translations[currentLanguage].prediction}: ${currentPredictionValue} (Lvl ${predictionLevel})`, {
                        body: `${translations[currentLanguage].period}: ${nextPeriod}\n${translations[currentLanguage].confidence_text} ${confidenceValue}%`,
                        icon: 'https://placehold.co/32x32/FF69B4/FFFFFF?text=AI' /* Updated icon color */
                    });
                } else if (currentPredictionType === 'color') {
                    new Notification(`${translations[currentLanguage].prediction}: ${currentPredictionValue} (Lvl ${predictionLevel})`, {
                        body: `${translations[currentLanguage].period}: ${nextPeriod}\n${translations[currentLanguage].confidence_text} ${confidenceValue}%`,
                        icon: 'https://placehold.co/32x32/FF69B4/FFFFFF?text=AI' /* Updated icon color */
                    });
                }
            }
        }

        function updateHistory() {
            const historyContainer = document.getElementById('history');
            if (!historyContainer) return; 
            historyContainer.innerHTML = '';

            historyData.forEach((entry, index) => {
                const status = entry.resultStatus.toLowerCase();
                const iconClass = {
                    win: 'fas fa-check-circle win-icon',
                    loss: 'fas fa-times-circle loss-icon',
                    pending: 'fas fa-hourglass-half pending-icon',
                    skipped: 'fas fa-ban skipped-icon'
                }[status] || 'fas fa-question-circle';
                const badgeClass = {
                    win: 'win-badge',
                    loss: 'loss-badge',
                    pending: 'pending-badge',
                    skipped: 'skipped-badge'
                }[status] || '';

                let predictionDisplay = '';
                let actualDisplay = '';
                let predictionLevelBadge = '';
                
                if (entry.confidenceLevel) {
                    predictionLevelBadge = `<span class="level-badge level-${entry.confidenceLevel}-badge">Lvl ${entry.confidenceLevel}</span>`;
                }
                
                if (entry.predictionType === 'size') {
                    predictionDisplay = `<span class="font-medium">${translations[currentLanguage].prediction}:</span> <span class="px-2 py-1 rounded-full ${entry.sizePrediction.toLowerCase()}-badge">${entry.sizePrediction}</span>`;
                    if (entry.resultStatus !== "Pending") {
                        actualDisplay = `<span class="font-medium">${translations[currentLanguage].actual}: ${entry.sizeResultType}</span>`;
                    }
                } else if (entry.predictionType === 'color') {
                    predictionDisplay = `<span class="font-medium">${translations[currentLanguage].prediction}:</span> <span class="px-2 py-1 rounded-full ${entry.colorPrediction.toLowerCase()}-badge">${entry.colorPrediction}</span>`;
                    if (entry.resultStatus !== "Pending") {
                        actualDisplay = `<span class="font-medium">${translations[currentLanguage].actual}: ${entry.colorResultType}</span>`;
                    }
                }

                const historyItem = document.createElement('div');
                historyItem.className = `history-item ${status} flex items-center justify-between p-4 rounded-xl`;
                historyItem.innerHTML = `
                    <div class="watermark">ORACLE X AI</div>
                    <div class="flex items-center space-x-3 w-full">
                        <div class="status-icon ${badgeClass}">
                            <i class="${iconClass}"></i>
                        </div>
                        <div class="flex-grow">
                            <p class="text-lg font-semibold">${entry.period.slice(-5)} ${predictionLevelBadge}</p>
                            <div class="flex items-center text-sm space-x-2 mt-1">
                                ${predictionDisplay}
                                ${entry.result !== "-" ? `<p class="text-sm">${translations[currentLanguage].result_number}: ${entry.result}</p>` : ''}
                                ${actualDisplay}
                            </div>
                            ${entry.confidence ? `<p class="text-sm mt-1">${translations[currentLanguage].confidence_text} ${entry.confidence}%</p>` : ''}
                            <p class="text-sm capitalize mt-1">${translations[currentLanguage].status}: ${status}</p>
                        </div>
                    </div>
                    <button class="delete-btn hover:text-primary-pink transition" data-index="${index}">
                        <i class="fas fa-trash-alt"></i>
                    </button>
                `;
                historyContainer.appendChild(historyItem);

                historyItem.querySelector('.delete-btn').addEventListener('click', () => {
                    showConfirmModal(translations[currentLanguage].delete_item_confirm, async () => {
                        const deletedPeriod = historyData[index].period;
                        historyData.splice(index, 1);
                        updateHistory();
                        updateStats();
                        await saveHistoryToFirebase(); 
                        showHistoryDeletedPopup(`${translations[currentLanguage].period} ${deletedPeriod} ${translations[currentLanguage].deleted_successfully}`);
                    });
                });
            });

            let mostFrequent = '-';
            let leastFrequent = '-';
            const numberCounts = {};
            historyData.forEach(entry => {
                if (entry.result !== '-') {
                    numberCounts[entry.result] = (numberCounts[entry.result] || 0) + 1;
                }
            });
            const sortedCounts = Object.entries(numberCounts).sort((a, b) => b[1] - a[1]);
            if (sortedCounts.length > 0) {
                mostFrequent = sortedCounts[0][0];
                leastFrequent = sortedCounts[sortedCounts.length - 1][0];
            }
            const mostFrequentElement = document.getElementById('mostFrequent');
            if (mostFrequentElement) mostFrequentElement.textContent = mostFrequent;
            const leastFrequentElement = document.getElementById('leastFrequent');
            if (leastFrequentElement) leastFrequentElement.textContent = leastFrequent;
        }

        function updateStats() {
            const wins = historyData.filter(item => item.resultStatus === "WIN").length;
            const losses = historyData.filter(item => item.resultStatus === "LOSS").length;
            const total = wins + losses;
            const accuracy = total > 0 ? ((wins / total) * 100).toFixed(2) : 0;

            const homeWinRateElement = document.getElementById("homeWinRate");
            if (homeWinRateElement) homeWinRateElement.textContent = `${accuracy}%`;
            const totalWinBetsElement = document.getElementById("totalWinBets");
            if (totalWinBetsElement) totalWinBetsElement.textContent = wins;
            const totalLossBetsElement = document.getElementById("totalLossBets");
            if (totalLossBetsElement) totalLossBetsElement.textContent = losses;

            const statsTotalWinsElement = document.getElementById("statsTotalWins");
            if (statsTotalWinsElement) statsTotalWinsElement.textContent = wins;
            const statsTotalLossesElement = document.getElementById("statsTotalLosses");
            if (statsTotalLossesElement) statsTotalLossesElement.textContent = losses;
            const statsWinRateElement = document.getElementById("statsWinRate");
            if (statsWinRateElement) statsWinRateElement.textContent = `${accuracy}%`;
            const currentStreakElement = document.getElementById("currentStreak");
            if (currentStreakElement) currentStreakElement.textContent = streak;
            const lastFiveResultsElement = document.getElementById("lastFiveResults");
            if (lastFiveResultsElement) lastFiveResultsElement.textContent = historyData.slice(0, 5).map(item => item.resultStatus === 'WIN' ? 'W' : (item.resultStatus === 'LOSS' ? 'L' : '-')).join(', ') || '-';

            const settingsTotalWinsElement = document.getElementById("settingsTotalWins");
            if (settingsTotalWinsElement) settingsTotalWinsElement.textContent = `${translations[currentLanguage].total_wins_display} ${wins}`;
            const settingsTotalLossesElement = document.getElementById("settingsTotalLosses");
            if (settingsTotalLossesElement) settingsTotalLossesElement.textContent = `${translations[currentLanguage].total_losses_display} ${losses}`;
        }

        document.getElementById('deleteAllHistoryBtn').addEventListener('click', () => {
            showConfirmModal(translations[currentLanguage].delete_all_confirm, async () => {
                historyData = [];
                streak = 0;
                winLevel = 0;
                lossStreak = 0;
                consecutiveLosses = 0;
                updateHistory();
                updateStats();
                await saveHistoryToFirebase(); 
                showHistoryDeletedPopup(translations[currentLanguage].history_deleted_message);
            });
        });

        function requestNotificationPermission() {
             if (isNotificationsEnabled && Notification.permission !== 'granted') {
                Notification.requestPermission();
            }
        }
       
        // --- Login Page JavaScript ---
        function getDeviceId() {
            let id = localStorage.getItem("device_id");
            if (!id) {
                if (crypto.randomUUID) {
                    id = crypto.randomUUID();
                } else {
                    id = 'id-' + Math.random().toString(36).substr(2, 9) + '-' + Date.now();
                }
                localStorage.setItem("device_id", id);
            }
            return id;
        }

        function resetForm() {
            const accessKeyInput = document.getElementById("accessKey");
            const errorDiv = document.getElementById("error");
            const successDiv = document.getElementById("success");
            const loadingDiv = document.getElementById("loading");

            if (accessKeyInput) accessKeyInput.value = "";
            if (errorDiv) errorDiv.innerText = "";
            if (successDiv) successDiv.innerText = "";
            if (loadingDiv) loadingDiv.style.display = "none";
            gsap.to('#error', { opacity: 0, duration: 0.3 });
            gsap.to('#success', { opacity: 0, duration: 0.3 });
        }

        function displayLastKey() {
            const lastKeyElement = document.getElementById("lastKey");
            if (lastKeyElement) { 
                const lastKey = localStorage.getItem("last_key");
                lastKeyElement.innerText = lastKey ? `Last Key: ${lastKey}` : "Last Key: None";
            } else {
                console.error("Element with ID 'lastKey' not found.");
            }
        }

        window.handleLogin = async function () {
            const key = document.getElementById("accessKey").value.trim();
            const errorDiv = document.getElementById("error");
            const successDiv = document.getElementById("success");
            const loadingDiv = document.getElementById("loading");
            const userDeviceId = getDeviceId(); 

            if (errorDiv) errorDiv.innerText = "";
            if (successDiv) successDiv.innerText = "";
            if (loadingDiv) loadingDiv.style.display = "block";

            if (!key) {
                if (loadingDiv) loadingDiv.style.display = "none";
                if (errorDiv) errorDiv.innerText = "PLEASE ENTER ACCESS KEY.";
                gsap.to('#error', {
                    scale: 1,
                    opacity: 1,
                    duration: 0.5,
                    ease: 'elastic.out(1, 0.6)'
                });
                setTimeout(() => { resetForm(); }, 2000);
                return;
            }

            while (!isAuthReady || currentUserUid === null) {
                await new Promise(resolve => setTimeout(resolve, 100)); 
            }

            try {
                console.log("handleLogin: Current Firebase User UID before fetching key:", auth.currentUser?.uid);

                const keySnapshot = await get(child(accessKeysRef, key));

                if (!keySnapshot.exists()) {
                    if (loadingDiv) loadingDiv.style.display = "none";
                    if (errorDiv) errorDiv.innerText = "INVALID ACCESS KEY.";
                    gsap.to('#error', { scale: 1, opacity: 1, duration: 0.5, ease: 'elastic.out(1, 0.6)' });
                    setTimeout(() => { resetForm(); }, 2000);
                    return;
                }

                const keyData = keySnapshot.val();
                const now = Date.now();

                if (!keyData.active) {
                    if (loadingDiv) loadingDiv.style.display = "none";
                    if (errorDiv) errorDiv.innerText = "KEY IS INACTIVE.";
                    gsap.to('#error', { scale: 1, opacity: 1, duration: 0.5, ease: 'elastic.out(1, 0.6)' });
                    setTimeout(() => { resetForm(); }, 2000);
                    return;
                }

                if (keyData.expiry < now) {
                    if (loadingDiv) loadingDiv.style.display = "none";
                    if (errorDiv) errorDiv.innerText = "KEY HAS EXPIRED.";
                    gsap.to('#error', { scale: 1, opacity: 1, duration: 0.5, ease: 'elastic.out(1, 0.6)' });
                    setTimeout(() => { resetForm(); }, 2000);
                    return;
                }

                if (keyData.deviceId) { 
                    if (keyData.deviceId !== userDeviceId) { 
                        if (loadingDiv) loadingDiv.style.display = "none";
                        if (errorDiv) errorDiv.innerText = `KEY BOUND TO ANOTHER DEVICE. YOUR ID: ${userDeviceId}`;
                        gsap.to('#error', { scale: 1, opacity: 1, duration: 0.5, ease: 'elastic.out(1, 0.6)' });
                        setTimeout(() => { resetForm(); }, 3000); 
                        return;
                    }
                }

                if (successDiv) successDiv.innerText = "LOGIN SUCCESSFUL!";
                gsap.to('#success', {
                    scale: 1,
                    opacity: 1,
                    duration: 0.5,
                    ease: 'elastic.out(1, 0.6)'
                });
                localStorage.setItem('last_key', key);
                displayLastKey();
                
                const loginScreen = document.getElementById('loginScreen');
                const mainAppScreen = document.getElementById('mainAppScreen');
                if (loginScreen && mainAppScreen) {
                    gsap.to(loginScreen, {
                        opacity: 0,
                        duration: 0.8,
                        ease: 'power2.out',
                        onComplete: () => {
                            loginScreen.style.display = 'none';
                            mainAppScreen.style.display = 'block';
                            gsap.fromTo(mainAppScreen, 
                                { opacity: 0, y: 50 }, 
                                { opacity: 1, y: 0, duration: 1, ease: 'power3.out' }
                            );
                            if (!predictionInterval) { 
                                predictionInterval = setInterval(updatePrediction, 5000);
                                updatePrediction(); 
                            }
                            requestNotificationPermission(); 
                            // updateAdvancedStatusBarVisibility(); // Already called by applySettingsToUI
                        }
                    });
                }

            } catch (error) {
                console.error("Firebase Login Error:", error);
                if (loadingDiv) loadingDiv.style.display = "none";
                if (errorDiv) errorDiv.innerText = "LOGIN FAILED: " + error.message;
                gsap.to('#error', { scale: 1, opacity: 1, duration: 0.5, ease: 'elastic.out(1, 0.6)' });
                setTimeout(() => { resetForm(); }, 2000);
            }
        };

        window.getKey = function () {
            const message = encodeURIComponent("HELLO @ORACLEXAIADMIN, I NEED AN ACCESS KEY.");
            window.open(`https://t.me/ORACLEXAIADMIN?text=${message}`, '_blank');
        };

        function populateLicenseInput() {
            const licenseInput = document.getElementById('accessKey');
            const storedKey = localStorage.getItem('last_key');
            if (licenseInput && storedKey) {
                licenseInput.value = storedKey;
            }
        }

        function createStarsLogin() {
            const container = document.getElementById('stars-container-login');
            if (!container) return; 
            const starCount = 40;
            
            for (let i = 0; i < starCount; i++) {
                const star = document.createElement('div');
                star.classList.add('star');
                
                const size = Math.random() * 2 + 1;
                const posX = Math.random() * 100;
                const posY = Math.random() * 100;
                const duration = Math.random() * 4 + 2 + 's';
                const delay = Math.random() * 4 + 's';
                
                star.style.width = `${size}px`;
                star.style.height = `${size}px`;
                star.style.left = `${posX}%`;
                star.style.top = `${posY}%`;
                star.style.setProperty('--duration', duration);
                star.style.animationDelay = delay;
                
                container.appendChild(star);
            }
        }

        function createConfettiLogin() {
            const container = document.getElementById('confetti-container-login');
            if (!container) return; 
            const confettiCount = 80;
            
            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.classList.add('confetti');
                
                const size = Math.random() * 8 + 4;
                const posX = Math.random() * window.innerWidth;
                const posY = -20;
                const color = `hsl(${Math.random() * 180 + 180}, 80%, 70%)`;
                const rotation = Math.random() * 360;
                const shape = Math.random() > 0.5 ? '50%' : '0';
                
                confetti.style.width = `${size}px`;
                confetti.style.height = `${size}px`;
                confetti.style.left = `${posX}px`;
                confetti.style.top = `${posY}px`;
                confetti.style.backgroundColor = color;
                confetti.style.borderRadius = shape;
                confetti.style.transform = `rotate(${rotation}deg)`;
                
                container.appendChild(confetti);
            }
        }

        function animateConfettiLogin() {
            const confetti = document.querySelectorAll('#confetti-container-login .confetti');
            
            confetti.forEach((piece, index) => {
                const duration = Math.random() * 2.5 + 1.5;
                const delay = index * 0.015;
                
                gsap.to(piece, {
                    y: window.innerHeight + 80,
                    x: `+=${Math.random() * 150 - 75}`,
                    rotation: Math.random() * 360,
                    opacity: 1,
                    duration: duration,
                    delay: delay,
                    ease: 'power1.out',
                    onComplete: () => {
                        piece.remove();
                    }
                });
            });
        }

        window.copyDeviceId = function () {
            const deviceId = getDeviceId();
            const tempInput = document.createElement('textarea');
            tempInput.value = deviceId;
            tempInput.style.position = 'absolute'; 
            tempInput.style.left = '-9999px';
            tempInput.style.top = '0';
            document.body.appendChild(tempInput);
            
            tempInput.select();
            
            let successful = false;
            try {
                successful = document.execCommand('copy');
                if (successful) {
                    const copyBtn = document.getElementById('copyDeviceIdButton');
                    const copyText = document.getElementById('copyText');
                    
                    if (copyBtn && copyText) {
                        createConfettiLogin(); 
                        animateConfettiLogin(); 
                        
                        copyBtn.classList.add('copied');
                        copyText.innerHTML = 'Copied!';
                        
                        gsap.to(copyBtn, {
                            scale: 1.08,
                            duration: 0.15,
                            yoyo: true,
                            repeat: 1,
                            ease: 'power2.inOut',
                            onComplete: () => {
                                setTimeout(() => {
                                    copyBtn.classList.remove('copied');
                                    copyText.innerHTML = 'Copy Device ID';
                                }, 1200);
                            }
                        });
                    }
                } else {
                    console.error('Failed to copy using execCommand. Fallback to manual.');
                    const messageBox = document.createElement('div');
                    messageBox.style.cssText = `
                        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                        background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;
                        padding: 15px; border-radius: 5px; z-index: 1000;
                        text-align: center; font-size: 0.9em;
                    `;
                    messageBox.innerHTML = `Copy failed.<br>Please copy Device ID manually: <br><strong>${deviceId}</strong>`;
                    document.body.appendChild(messageBox);
                    setTimeout(() => messageBox.remove(), 5000); 
                }
            } catch (err) {
                console.error('Error attempting to copy: ', err);
                const messageBox = document.createElement('div');
                messageBox.style.cssText = `
                    position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;
                    padding: 15px; border-radius: 5px; z-index: 1000;
                    text-align: center; font-size: 0.9em;
                `;
                messageBox.innerHTML = `Copy failed.<br>Please copy Device ID manually: <br><strong>${deviceId}</strong>`;
                document.body.appendChild(messageBox);
                setTimeout(() => messageBox.remove(), 5000); 
            } finally {
                document.body.removeChild(tempInput); 
            }
        };


        const loginAccessKeyInput = document.getElementById('accessKey');
        if (loginAccessKeyInput) {
            loginAccessKeyInput.addEventListener('focus', () => {
                gsap.to('.input-icon', {
                    scale: 1.1,
                    duration: 0.25,
                    ease: 'back.out'
                });
            });
            
            loginAccessKeyInput.addEventListener('blur', () => {
                gsap.to('.input-icon', {
                    scale: 1,
                    duration: 0.25,
                    ease: 'back.out'
                });
            });
        }

        document.addEventListener('DOMContentLoaded', () => {
            populateLicenseInput();
            displayLastKey();
            createStarsLogin(); 

            gsap.to('#loginContainer', {
                opacity: 1,
                visibility: 'visible',
                y: 0,
                duration: 0.7,
                ease: 'power3.out',
                onComplete: () => {
                    const loginContainer = document.getElementById('loginContainer');
                    if (loginContainer) loginContainer.classList.add('visible');
                }
            });

            gsap.to('.logo-container', {
                scale: 1,
                opacity: 1,
                duration: 0.6,
                delay: 0.15,
                ease: 'elastic.out(1, 0.6)'
            });

            gsap.to('#inputGroup', {
                x: 0,
                opacity: 1,
                duration: 0.5,
                delay: 0.3,
                ease: 'power2.out'
            });

            const submitBtnElement = document.getElementById('submitBtn');
            if (submitBtnElement) {
                gsap.to(submitBtnElement, {
                    y: 0,
                    opacity: 1,
                    duration: 0.5,
                    delay: 0.6,
                    ease: 'power2.out'
                });
            }

            const copyDeviceIdButtonElement = document.getElementById('copyDeviceIdButton');
            if (copyDeviceIdButtonElement) { 
                gsap.to(copyDeviceIdButtonElement, {
                    y: 0,
                    opacity: 1,
                    duration: 0.5,
                    delay: 0.75,
                    ease: 'power2.out'
                });
            }

            const socialLinksElement = document.getElementById('socialLinks');
            if (socialLinksElement) { 
                gsap.to(socialLinksElement, {
                    y: 0,
                    opacity: 1,
                    duration: 0.5,
                    delay: 0.9,
                    ease: 'power2.out',
                    onComplete: () => {
                        gsap.to('.social-link', {
                            y: -8,
                            duration: 0.4,
                            stagger: 0.08,
                            repeat: -1,
                            yoyo: true,
                            ease: 'sine.inOut'
                        });
                    }
                });
            }

            gsap.to('.floating-element', {
                y: 15,
                rotation: 3,
                duration: 4,
                repeat: -1,
                yoyo: true,
                ease: 'sine.inOut',
                stagger: 0.2
            });

            if (submitBtnElement) {
                submitBtnElement.addEventListener('mouseenter', () => {
                    gsap.to(submitBtnElement, { y: -2, duration: 0.25, ease: 'power2.out' });
                });
                submitBtnElement.addEventListener('mouseleave', () => {
                    gsap.to(submitBtnElement, { y: 0, duration: 0.25, ease: 'power2.out' });
                });
            }
        });
    </script>
</body>
</html>
